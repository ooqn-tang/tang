{
  "version": 3,
  "sources": ["../tinymce/models/dom/model.js", "../tinymce/models/dom/index.js", "dep:tinymce_models_dom"],
  "sourcesContent": ["/**\n * TinyMCE version 6.1.0 (2022-06-29)\n */\n\n(function () {\n    'use strict';\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.ModelManager');\n\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const eq$2 = t => a => t === a;\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isArray = isType$1('array');\n    const isNull = eq$2(null);\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    const noop = () => {\n    };\n    const compose = (fa, fb) => {\n      return (...args) => {\n        return fa(fb.apply(null, args));\n      };\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const identity = x => {\n      return x;\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const die = msg => {\n      return () => {\n        throw new Error(msg);\n      };\n    };\n    const apply = f => {\n      return f();\n    };\n    const never = constant(false);\n    const always = constant(true);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const range$1 = (num, f) => {\n      const r = [];\n      for (let i = 0; i < num; i++) {\n        r.push(f(i));\n      }\n      return r;\n    };\n    const map$1 = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$2 = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const partition = (xs, pred) => {\n      const pass = [];\n      const fail = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const arr = pred(x, i) ? pass : fail;\n        arr.push(x);\n      }\n      return {\n        pass,\n        fail\n      };\n    };\n    const filter$2 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const foldr = (xs, f, acc) => {\n      eachr(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const foldl = (xs, f, acc) => {\n      each$2(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find$1 = (xs, pred) => {\n      return findUntil(xs, pred, never);\n    };\n    const findIndex = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(i);\n        }\n      }\n      return Optional.none();\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind$2 = (xs, f) => flatten(map$1(xs, f));\n    const forall = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        const x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const mapToObject = (xs, f) => {\n      const r = {};\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        r[String(x)] = f(x, i);\n      }\n      return r;\n    };\n    const sort$1 = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    const get$d = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$d(xs, 0);\n    const last$2 = xs => get$d(xs, xs.length - 1);\n    const findMap = (arr, f) => {\n      for (let i = 0; i < arr.length; i++) {\n        const r = f(arr[i], i);\n        if (r.isSome()) {\n          return r;\n        }\n      }\n      return Optional.none();\n    };\n\n    const keys = Object.keys;\n    const hasOwnProperty = Object.hasOwnProperty;\n    const each$1 = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each$1(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      const r = {};\n      each$1(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n      return r;\n    };\n    const filter$1 = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n    const mapToArray = (obj, f) => {\n      const r = [];\n      each$1(obj, (value, name) => {\n        r.push(f(value, name));\n      });\n      return r;\n    };\n    const values = obj => {\n      return mapToArray(obj, identity);\n    };\n    const get$c = (obj, key) => {\n      return has$1(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has$1 = (obj, key) => hasOwnProperty.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has$1(obj, key) && obj[key] !== undefined && obj[key] !== null;\n    const isEmpty = r => {\n      for (const x in r) {\n        if (hasOwnProperty.call(r, x)) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type = element => element.dom.nodeType;\n    const isType = t => element => type(element) === t;\n    const isComment = element => type(element) === COMMENT || name(element) === '#comment';\n    const isElement = isType(ELEMENT);\n    const isText = isType(TEXT);\n    const isDocument = isType(DOCUMENT);\n    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement(e) && name(e) === tag;\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set$2 = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const setAll$1 = (element, attrs) => {\n      const dom = element.dom;\n      each$1(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const setOptions = (element, attrs) => {\n      each$1(attrs, (v, k) => {\n        v.fold(() => {\n          remove$7(element, k);\n        }, value => {\n          rawSet(element.dom, k, value);\n        });\n      });\n    };\n    const get$b = (element, key) => {\n      const v = element.dom.getAttribute(key);\n      return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$b(element, key));\n    const remove$7 = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n    const clone$2 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const fromHtml$1 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$1(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$1(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$1(node);\n    };\n    const fromDom$1 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint$1 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);\n    const SugarElement = {\n      fromHtml: fromHtml$1,\n      fromTag,\n      fromText,\n      fromDom: fromDom$1,\n      fromPoint: fromPoint$1\n    };\n\n    const is$2 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all$1 = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map$1(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq$1 = (e1, e2) => e1.dom === e2.dom;\n    const contains$1 = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n    const is$1 = is$2;\n\n    const owner = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument(dos) ? dos : owner(dos);\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const parents = (element, isRoot) => {\n      const stop = isFunction(isRoot) ? isRoot : never;\n      let dom = element.dom;\n      const ret = [];\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\n        const rawParent = dom.parentNode;\n        const p = SugarElement.fromDom(rawParent);\n        ret.push(p);\n        if (stop(p) === true) {\n          break;\n        } else {\n          dom = rawParent;\n        }\n      }\n      return ret;\n    };\n    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const children$2 = element => map$1(element.dom.childNodes, SugarElement.fromDom);\n    const child$2 = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child$2(element, 0);\n\n    const before$3 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after$5 = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const appendAt = (parent, element, index) => {\n      child$2(parent, index).fold(() => {\n        append$1(parent, element);\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const wrap = (element, wrapper) => {\n      before$3(element, wrapper);\n      append$1(wrapper, element);\n    };\n\n    const after$4 = (marker, elements) => {\n      each$2(elements, (x, i) => {\n        const e = i === 0 ? marker : elements[i - 1];\n        after$5(e, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$2(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$2(children$2(element), rogue => {\n        remove$6(rogue);\n      });\n    };\n    const remove$6 = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n    const unwrap = wrapper => {\n      const children = children$2(wrapper);\n      if (children.length > 0) {\n        after$4(wrapper, children);\n      }\n      remove$6(wrapper);\n    };\n\n    const clone$1 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const shallow = original => clone$1(original, false);\n    const deep = original => clone$1(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$2(original);\n      setAll$1(nu, attributes);\n      return nu;\n    };\n    const copy$2 = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      const cloneChildren = children$2(deep(original));\n      append(nu, cloneChildren);\n      return nu;\n    };\n    const mutate$1 = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after$5(original, nu);\n      const children = children$2(original);\n      append(nu, children);\n      remove$6(original);\n      return nu;\n    };\n\n    const validSectionList = [\n      'tfoot',\n      'thead',\n      'tbody',\n      'colgroup'\n    ];\n    const isValidSection = parentName => contains$2(validSectionList, parentName);\n    const grid = (rows, columns) => ({\n      rows,\n      columns\n    });\n    const address = (row, column) => ({\n      row,\n      column\n    });\n    const detail = (element, rowspan, colspan) => ({\n      element,\n      rowspan,\n      colspan\n    });\n    const detailnew = (element, rowspan, colspan, isNew) => ({\n      element,\n      rowspan,\n      colspan,\n      isNew\n    });\n    const extended = (element, rowspan, colspan, row, column, isLocked) => ({\n      element,\n      rowspan,\n      colspan,\n      row,\n      column,\n      isLocked\n    });\n    const rowdetail = (element, cells, section) => ({\n      element,\n      cells,\n      section\n    });\n    const rowdetailnew = (element, cells, section, isNew) => ({\n      element,\n      cells,\n      section,\n      isNew\n    });\n    const elementnew = (element, isNew, isLocked) => ({\n      element,\n      isNew,\n      isLocked\n    });\n    const rowcells = (element, cells, section, isNew) => ({\n      element,\n      cells,\n      section,\n      isNew\n    });\n    const bounds = (startRow, startCol, finishRow, finishCol) => ({\n      startRow,\n      startCol,\n      finishRow,\n      finishCol\n    });\n    const columnext = (element, colspan, column) => ({\n      element,\n      colspan,\n      column\n    });\n    const colgroup = (element, columns) => ({\n      element,\n      columns\n    });\n\n    const isShadowRoot = dos => isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const isSupported$1 = constant(supported);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n    const getOriginalEventTarget = event => {\n      if (isSupported$1() && isNonNullable(event.target)) {\n        const el = SugarElement.fromDom(event.target);\n        if (isElement(el) && isOpenShadowHost(el)) {\n          if (event.composed && event.composedPath) {\n            const composedPath = event.composedPath();\n            if (composedPath) {\n              return head(composedPath);\n            }\n          }\n        }\n      }\n      return Optional.from(event.target);\n    };\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n    const inBody = element => {\n      const dom = isText(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n    const body$1 = () => getBody$1(SugarElement.fromDom(document));\n    const getBody$1 = doc => {\n      const b = doc.dom.body;\n      if (b === null || b === undefined) {\n        throw new Error('Body is not available yet');\n      }\n      return SugarElement.fromDom(b);\n    };\n\n    const ancestors$4 = (scope, predicate, isRoot) => filter$2(parents(scope, isRoot), predicate);\n    const children$1 = (scope, predicate) => filter$2(children$2(scope), predicate);\n    const descendants$1 = (scope, predicate) => {\n      let result = [];\n      each$2(children$2(scope), x => {\n        if (predicate(x)) {\n          result = result.concat([x]);\n        }\n        result = result.concat(descendants$1(x, predicate));\n      });\n      return result;\n    };\n\n    const ancestors$3 = (scope, selector, isRoot) => ancestors$4(scope, e => is$2(e, selector), isRoot);\n    const children = (scope, selector) => children$1(scope, e => is$2(e, selector));\n    const descendants = (scope, selector) => all$1(selector, scope);\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$2 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$2 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$2, scope, predicate, isRoot);\n    };\n    const child$1 = (scope, predicate) => {\n      const pred = node => predicate(SugarElement.fromDom(node));\n      const result = find$1(scope.dom.childNodes, pred);\n      return result.map(SugarElement.fromDom);\n    };\n    const descendant$1 = (scope, predicate) => {\n      const descend = node => {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          const child = SugarElement.fromDom(node.childNodes[i]);\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(node.childNodes[i]);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope.dom);\n    };\n\n    const ancestor$1 = (scope, selector, isRoot) => ancestor$2(scope, e => is$2(e, selector), isRoot);\n    const child = (scope, selector) => child$1(scope, e => is$2(e, selector));\n    const descendant = (scope, selector) => one(selector, scope);\n    const closest$1 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$2(element, selector);\n      return ClosestOrAncestor(is, ancestor$1, scope, selector, isRoot);\n    };\n\n    const is = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const cat = arr => {\n      const r = [];\n      const push = x => {\n        r.push(x);\n      };\n      for (let i = 0; i < arr.length; i++) {\n        arr[i].each(push);\n      }\n      return r;\n    };\n    const bindFrom = (a, f) => a !== undefined && a !== null ? f(a) : Optional.none();\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const contains = (str, substr) => {\n      return str.indexOf(substr) !== -1;\n    };\n    const startsWith = (str, prefix) => {\n      return checkRange(str, prefix, 0);\n    };\n    const endsWith = (str, suffix) => {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n    const blank = r => s => s.replace(r, '');\n    const trim = blank(/^\\s+|\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const toFloat = value => {\n      const num = parseFloat(value);\n      return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const internalRemove = (dom, property) => {\n      if (isSupported(dom)) {\n        dom.style.removeProperty(property);\n      }\n    };\n    const set$1 = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n    const setAll = (element, css) => {\n      const dom = element.dom;\n      each$1(css, (v, k) => {\n        internalSet(dom, k, v);\n      });\n    };\n    const get$a = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n    const getRaw$2 = (element, property) => {\n      const dom = element.dom;\n      const raw = getUnsafeProperty(dom, property);\n      return Optional.from(raw).filter(r => r.length > 0);\n    };\n    const remove$5 = (element, property) => {\n      const dom = element.dom;\n      internalRemove(dom, property);\n      if (is(getOpt(element, 'style').map(trim), '')) {\n        remove$7(element, 'style');\n      }\n    };\n    const copy$1 = (source, target) => {\n      const sourceDom = source.dom;\n      const targetDom = target.dom;\n      if (isSupported(sourceDom) && isSupported(targetDom)) {\n        targetDom.style.cssText = sourceDom.style.cssText;\n      }\n    };\n\n    const getAttrValue = (cell, name, fallback = 0) => getOpt(cell, name).map(value => parseInt(value, 10)).getOr(fallback);\n    const getSpan = (cell, type) => getAttrValue(cell, type, 1);\n    const hasColspan = cellOrCol => {\n      if (isTag('col')(cellOrCol)) {\n        return getAttrValue(cellOrCol, 'span', 1) > 1;\n      } else {\n        return getSpan(cellOrCol, 'colspan') > 1;\n      }\n    };\n    const hasRowspan = cell => getSpan(cell, 'rowspan') > 1;\n    const getCssValue = (element, property) => parseInt(get$a(element, property), 10);\n    const minWidth = constant(10);\n    const minHeight = constant(10);\n\n    const firstLayer = (scope, selector) => {\n      return filterFirstLayer(scope, selector, always);\n    };\n    const filterFirstLayer = (scope, selector, predicate) => {\n      return bind$2(children$2(scope), x => {\n        if (is$2(x, selector)) {\n          return predicate(x) ? [x] : [];\n        } else {\n          return filterFirstLayer(x, selector, predicate);\n        }\n      });\n    };\n\n    const lookup = (tags, element, isRoot = never) => {\n      if (isRoot(element)) {\n        return Optional.none();\n      }\n      if (contains$2(tags, name(element))) {\n        return Optional.some(element);\n      }\n      const isRootOrUpperTable = elm => is$2(elm, 'table') || isRoot(elm);\n      return ancestor$1(element, tags.join(','), isRootOrUpperTable);\n    };\n    const cell = (element, isRoot) => lookup([\n      'td',\n      'th'\n    ], element, isRoot);\n    const cells$1 = ancestor => firstLayer(ancestor, 'th,td');\n    const columns$1 = ancestor => {\n      if (is$2(ancestor, 'colgroup')) {\n        return children(ancestor, 'col');\n      } else {\n        return bind$2(columnGroups(ancestor), columnGroup => children(columnGroup, 'col'));\n      }\n    };\n    const table = (element, isRoot) => closest$1(element, 'table', isRoot);\n    const rows$1 = ancestor => firstLayer(ancestor, 'tr');\n    const columnGroups = ancestor => table(ancestor).fold(constant([]), table => children(table, 'colgroup'));\n\n    const fromRowsOrColGroups = (elems, getSection) => map$1(elems, row => {\n      if (name(row) === 'colgroup') {\n        const cells = map$1(columns$1(row), column => {\n          const colspan = getAttrValue(column, 'span', 1);\n          return detail(column, 1, colspan);\n        });\n        return rowdetail(row, cells, 'colgroup');\n      } else {\n        const cells = map$1(cells$1(row), cell => {\n          const rowspan = getAttrValue(cell, 'rowspan', 1);\n          const colspan = getAttrValue(cell, 'colspan', 1);\n          return detail(cell, rowspan, colspan);\n        });\n        return rowdetail(row, cells, getSection(row));\n      }\n    });\n    const getParentSection = group => parent(group).map(parent => {\n      const parentName = name(parent);\n      return isValidSection(parentName) ? parentName : 'tbody';\n    }).getOr('tbody');\n    const fromTable$1 = table => {\n      const rows = rows$1(table);\n      const columnGroups$1 = columnGroups(table);\n      const elems = [\n        ...columnGroups$1,\n        ...rows\n      ];\n      return fromRowsOrColGroups(elems, getParentSection);\n    };\n    const fromPastedRows = (elems, section) => fromRowsOrColGroups(elems, () => section);\n\n    const cached = f => {\n      let called = false;\n      let r;\n      return (...args) => {\n        if (!called) {\n          called = true;\n          r = f.apply(null, args);\n        }\n        return r;\n      };\n    };\n\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n      const isiPhone = os.isiOS() && !isiPad;\n      const isMobile = os.isiOS() || os.isAndroid();\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n      const isPhone = isiPhone || isMobile && !isTablet;\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\n      return {\n        isiPad: constant(isiPad),\n        isiPhone: constant(isiPhone),\n        isTablet: constant(isTablet),\n        isPhone: constant(isPhone),\n        isTouch: constant(isTouch),\n        isAndroid: os.isAndroid,\n        isiOS: os.isiOS,\n        isWebView: constant(iOSwebview),\n        isDesktop: constant(isDesktop)\n      };\n    };\n\n    const firstMatch = (regexes, s) => {\n      for (let i = 0; i < regexes.length; i++) {\n        const x = regexes[i];\n        if (x.test(s)) {\n          return x;\n        }\n      }\n      return undefined;\n    };\n    const find = (regexes, agent) => {\n      const r = firstMatch(regexes, agent);\n      if (!r) {\n        return {\n          major: 0,\n          minor: 0\n        };\n      }\n      const group = i => {\n        return Number(agent.replace(r, '$' + i));\n      };\n      return nu$2(group(1), group(2));\n    };\n    const detect$5 = (versionRegexes, agent) => {\n      const cleanedAgent = String(agent).toLowerCase();\n      if (versionRegexes.length === 0) {\n        return unknown$2();\n      }\n      return find(versionRegexes, cleanedAgent);\n    };\n    const unknown$2 = () => {\n      return nu$2(0, 0);\n    };\n    const nu$2 = (major, minor) => {\n      return {\n        major,\n        minor\n      };\n    };\n    const Version = {\n      nu: nu$2,\n      detect: detect$5,\n      unknown: unknown$2\n    };\n\n    const detectBrowser$1 = (browsers, userAgentData) => {\n      return findMap(userAgentData.brands, uaBrand => {\n        const lcBrand = uaBrand.brand.toLowerCase();\n        return find$1(browsers, browser => {\n          var _a;\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        }).map(info => ({\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        }));\n      });\n    };\n\n    const detect$4 = (candidates, userAgent) => {\n      const agent = String(userAgent).toLowerCase();\n      return find$1(candidates, candidate => {\n        return candidate.search(agent);\n      });\n    };\n    const detectBrowser = (browsers, userAgent) => {\n      return detect$4(browsers, userAgent).map(browser => {\n        const version = Version.detect(browser.versionRegexes, userAgent);\n        return {\n          current: browser.name,\n          version\n        };\n      });\n    };\n    const detectOs = (oses, userAgent) => {\n      return detect$4(oses, userAgent).map(os => {\n        const version = Version.detect(os.versionRegexes, userAgent);\n        return {\n          current: os.name,\n          version\n        };\n      });\n    };\n\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n    const checkContains = target => {\n      return uastring => {\n        return contains(uastring, target);\n      };\n    };\n    const browsers = [\n      {\n        name: 'Edge',\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n        search: uastring => {\n          return contains(uastring, 'edge/') && contains(uastring, 'chrome') && contains(uastring, 'safari') && contains(uastring, 'applewebkit');\n        }\n      },\n      {\n        name: 'Chromium',\n        brand: 'Chromium',\n        versionRegexes: [\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\n          normalVersionRegex\n        ],\n        search: uastring => {\n          return contains(uastring, 'chrome') && !contains(uastring, 'chromeframe');\n        }\n      },\n      {\n        name: 'IE',\n        versionRegexes: [\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\n        ],\n        search: uastring => {\n          return contains(uastring, 'msie') || contains(uastring, 'trident');\n        }\n      },\n      {\n        name: 'Opera',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\n        ],\n        search: checkContains('opera')\n      },\n      {\n        name: 'Firefox',\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n        search: checkContains('firefox')\n      },\n      {\n        name: 'Safari',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\n        ],\n        search: uastring => {\n          return (contains(uastring, 'safari') || contains(uastring, 'mobile/')) && contains(uastring, 'applewebkit');\n        }\n      }\n    ];\n    const oses = [\n      {\n        name: 'Windows',\n        search: checkContains('win'),\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'iOS',\n        search: uastring => {\n          return contains(uastring, 'iphone') || contains(uastring, 'ipad');\n        },\n        versionRegexes: [\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\n        ]\n      },\n      {\n        name: 'Android',\n        search: checkContains('android'),\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'macOS',\n        search: checkContains('mac os x'),\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n      },\n      {\n        name: 'Linux',\n        search: checkContains('linux'),\n        versionRegexes: []\n      },\n      {\n        name: 'Solaris',\n        search: checkContains('sunos'),\n        versionRegexes: []\n      },\n      {\n        name: 'FreeBSD',\n        search: checkContains('freebsd'),\n        versionRegexes: []\n      },\n      {\n        name: 'ChromeOS',\n        search: checkContains('cros'),\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n      }\n    ];\n    const PlatformInfo = {\n      browsers: constant(browsers),\n      oses: constant(oses)\n    };\n\n    const edge = 'Edge';\n    const chromium = 'Chromium';\n    const ie = 'IE';\n    const opera = 'Opera';\n    const firefox = 'Firefox';\n    const safari = 'Safari';\n    const unknown$1 = () => {\n      return nu$1({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$1 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isBrowser = name => () => current === name;\n      return {\n        current,\n        version,\n        isEdge: isBrowser(edge),\n        isChromium: isBrowser(chromium),\n        isIE: isBrowser(ie),\n        isOpera: isBrowser(opera),\n        isFirefox: isBrowser(firefox),\n        isSafari: isBrowser(safari)\n      };\n    };\n    const Browser = {\n      unknown: unknown$1,\n      nu: nu$1,\n      edge: constant(edge),\n      chromium: constant(chromium),\n      ie: constant(ie),\n      opera: constant(opera),\n      firefox: constant(firefox),\n      safari: constant(safari)\n    };\n\n    const windows = 'Windows';\n    const ios = 'iOS';\n    const android = 'Android';\n    const linux = 'Linux';\n    const macos = 'macOS';\n    const solaris = 'Solaris';\n    const freebsd = 'FreeBSD';\n    const chromeos = 'ChromeOS';\n    const unknown = () => {\n      return nu({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu = info => {\n      const current = info.current;\n      const version = info.version;\n      const isOS = name => () => current === name;\n      return {\n        current,\n        version,\n        isWindows: isOS(windows),\n        isiOS: isOS(ios),\n        isAndroid: isOS(android),\n        isMacOS: isOS(macos),\n        isLinux: isOS(linux),\n        isSolaris: isOS(solaris),\n        isFreeBSD: isOS(freebsd),\n        isChromeOS: isOS(chromeos)\n      };\n    };\n    const OperatingSystem = {\n      unknown,\n      nu,\n      windows: constant(windows),\n      ios: constant(ios),\n      android: constant(android),\n      linux: constant(linux),\n      macos: constant(macos),\n      solaris: constant(solaris),\n      freebsd: constant(freebsd),\n      chromeos: constant(chromeos)\n    };\n\n    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {\n      const browsers = PlatformInfo.browsers();\n      const oses = PlatformInfo.oses();\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n      return {\n        browser,\n        os,\n        deviceType\n      };\n    };\n    const PlatformDetection = { detect: detect$3 };\n\n    const mediaMatch = query => window.matchMedia(query).matches;\n    let platform = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n    const detect$2 = () => platform();\n\n    const Dimension = (name, getOffset) => {\n      const set = (element, h) => {\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n        }\n        const dom = element.dom;\n        if (isSupported(dom)) {\n          dom.style[name] = h + 'px';\n        }\n      };\n      const get = element => {\n        const r = getOffset(element);\n        if (r <= 0 || r === null) {\n          const css = get$a(element, name);\n          return parseFloat(css) || 0;\n        }\n        return r;\n      };\n      const getOuter = get;\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n        const val = get$a(element, property);\n        const value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n      const max = (element, value, properties) => {\n        const cumulativeInclusions = aggregate(element, properties);\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n        return absoluteMax;\n      };\n      return {\n        set,\n        get,\n        getOuter,\n        aggregate,\n        max\n      };\n    };\n\n    const toNumber = (px, fallback) => toFloat(px).getOr(fallback);\n    const getProp = (element, name, fallback) => toNumber(get$a(element, name), fallback);\n    const calcContentBoxSize = (element, size, upper, lower) => {\n      const paddingUpper = getProp(element, `padding-${ upper }`, 0);\n      const paddingLower = getProp(element, `padding-${ lower }`, 0);\n      const borderUpper = getProp(element, `border-${ upper }-width`, 0);\n      const borderLower = getProp(element, `border-${ lower }-width`, 0);\n      return size - paddingUpper - paddingLower - borderUpper - borderLower;\n    };\n    const getCalculatedWidth = (element, boxSizing) => {\n      const dom = element.dom;\n      const width = dom.getBoundingClientRect().width || dom.offsetWidth;\n      return boxSizing === 'border-box' ? width : calcContentBoxSize(element, width, 'left', 'right');\n    };\n    const getHeight$1 = element => getProp(element, 'height', element.dom.offsetHeight);\n    const getWidth = element => getProp(element, 'width', element.dom.offsetWidth);\n    const getInnerWidth = element => getCalculatedWidth(element, 'content-box');\n\n    const api$2 = Dimension('width', element => element.dom.offsetWidth);\n    const get$9 = element => api$2.get(element);\n    const getOuter$2 = element => api$2.getOuter(element);\n    const getInner = getInnerWidth;\n    const getRuntime$1 = getWidth;\n\n    const addCells = (gridRow, index, cells) => {\n      const existingCells = gridRow.cells;\n      const before = existingCells.slice(0, index);\n      const after = existingCells.slice(index);\n      const newCells = before.concat(cells).concat(after);\n      return setCells(gridRow, newCells);\n    };\n    const addCell = (gridRow, index, cell) => addCells(gridRow, index, [cell]);\n    const mutateCell = (gridRow, index, cell) => {\n      const cells = gridRow.cells;\n      cells[index] = cell;\n    };\n    const setCells = (gridRow, cells) => rowcells(gridRow.element, cells, gridRow.section, gridRow.isNew);\n    const mapCells = (gridRow, f) => {\n      const cells = gridRow.cells;\n      const r = map$1(cells, f);\n      return rowcells(gridRow.element, r, gridRow.section, gridRow.isNew);\n    };\n    const getCell = (gridRow, index) => gridRow.cells[index];\n    const getCellElement = (gridRow, index) => getCell(gridRow, index).element;\n    const cellLength = gridRow => gridRow.cells.length;\n    const extractGridDetails = grid => {\n      const result = partition(grid, row => row.section === 'colgroup');\n      return {\n        rows: result.fail,\n        cols: result.pass\n      };\n    };\n    const clone = (gridRow, cloneRow, cloneCell) => {\n      const newCells = map$1(gridRow.cells, cloneCell);\n      return rowcells(cloneRow(gridRow.element), newCells, gridRow.section, true);\n    };\n\n    const LOCKED_COL_ATTR = 'data-snooker-locked-cols';\n    const getLockedColumnsFromTable = table => getOpt(table, LOCKED_COL_ATTR).bind(lockedColStr => Optional.from(lockedColStr.match(/\\d+/g))).map(lockedCols => mapToObject(lockedCols, always));\n    const getLockedColumnsFromGrid = grid => {\n      const locked = foldl(extractGridDetails(grid).rows, (acc, row) => {\n        each$2(row.cells, (cell, idx) => {\n          if (cell.isLocked) {\n            acc[idx] = true;\n          }\n        });\n        return acc;\n      }, {});\n      const lockedArr = mapToArray(locked, (_val, key) => parseInt(key, 10));\n      return sort$1(lockedArr);\n    };\n\n    const key = (row, column) => {\n      return row + ',' + column;\n    };\n    const getAt = (warehouse, row, column) => Optional.from(warehouse.access[key(row, column)]);\n    const findItem = (warehouse, item, comparator) => {\n      const filtered = filterItems(warehouse, detail => {\n        return comparator(item, detail.element);\n      });\n      return filtered.length > 0 ? Optional.some(filtered[0]) : Optional.none();\n    };\n    const filterItems = (warehouse, predicate) => {\n      const all = bind$2(warehouse.all, r => {\n        return r.cells;\n      });\n      return filter$2(all, predicate);\n    };\n    const generateColumns = rowData => {\n      const columnsGroup = {};\n      let index = 0;\n      each$2(rowData.cells, column => {\n        const colspan = column.colspan;\n        range$1(colspan, columnIndex => {\n          const colIndex = index + columnIndex;\n          columnsGroup[colIndex] = columnext(column.element, colspan, colIndex);\n        });\n        index += colspan;\n      });\n      return columnsGroup;\n    };\n    const generate$1 = list => {\n      const access = {};\n      const cells = [];\n      const tableOpt = head(list).map(rowData => rowData.element).bind(table);\n      const lockedColumns = tableOpt.bind(getLockedColumnsFromTable).getOr({});\n      let maxRows = 0;\n      let maxColumns = 0;\n      let rowCount = 0;\n      const {\n        pass: colgroupRows,\n        fail: rows\n      } = partition(list, rowData => rowData.section === 'colgroup');\n      each$2(rows, rowData => {\n        const currentRow = [];\n        each$2(rowData.cells, rowCell => {\n          let start = 0;\n          while (access[key(rowCount, start)] !== undefined) {\n            start++;\n          }\n          const isLocked = hasNonNullableKey(lockedColumns, start.toString());\n          const current = extended(rowCell.element, rowCell.rowspan, rowCell.colspan, rowCount, start, isLocked);\n          for (let occupiedColumnPosition = 0; occupiedColumnPosition < rowCell.colspan; occupiedColumnPosition++) {\n            for (let occupiedRowPosition = 0; occupiedRowPosition < rowCell.rowspan; occupiedRowPosition++) {\n              const rowPosition = rowCount + occupiedRowPosition;\n              const columnPosition = start + occupiedColumnPosition;\n              const newpos = key(rowPosition, columnPosition);\n              access[newpos] = current;\n              maxColumns = Math.max(maxColumns, columnPosition + 1);\n            }\n          }\n          currentRow.push(current);\n        });\n        maxRows++;\n        cells.push(rowdetail(rowData.element, currentRow, rowData.section));\n        rowCount++;\n      });\n      const {columns, colgroups} = last$2(colgroupRows).map(rowData => {\n        const columns = generateColumns(rowData);\n        const colgroup$1 = colgroup(rowData.element, values(columns));\n        return {\n          colgroups: [colgroup$1],\n          columns\n        };\n      }).getOrThunk(() => ({\n        colgroups: [],\n        columns: {}\n      }));\n      const grid$1 = grid(maxRows, maxColumns);\n      return {\n        grid: grid$1,\n        access,\n        all: cells,\n        columns,\n        colgroups\n      };\n    };\n    const fromTable = table => {\n      const list = fromTable$1(table);\n      return generate$1(list);\n    };\n    const justCells = warehouse => bind$2(warehouse.all, w => w.cells);\n    const justColumns = warehouse => values(warehouse.columns);\n    const hasColumns = warehouse => keys(warehouse.columns).length > 0;\n    const getColumnAt = (warehouse, columnIndex) => Optional.from(warehouse.columns[columnIndex]);\n    const Warehouse = {\n      fromTable,\n      generate: generate$1,\n      getAt,\n      findItem,\n      filterItems,\n      justCells,\n      justColumns,\n      hasColumns,\n      getColumnAt\n    };\n\n    const columns = (warehouse, isValidCell = always) => {\n      const grid = warehouse.grid;\n      const cols = range$1(grid.columns, identity);\n      const rowsArr = range$1(grid.rows, identity);\n      return map$1(cols, col => {\n        const getBlock = () => bind$2(rowsArr, r => Warehouse.getAt(warehouse, r, col).filter(detail => detail.column === col).toArray());\n        const isValid = detail => detail.colspan === 1 && isValidCell(detail.element);\n        const getFallback = () => Warehouse.getAt(warehouse, 0, col);\n        return decide(getBlock, isValid, getFallback);\n      });\n    };\n    const decide = (getBlock, isValid, getFallback) => {\n      const inBlock = getBlock();\n      const validInBlock = find$1(inBlock, isValid);\n      const detailOption = validInBlock.orThunk(() => Optional.from(inBlock[0]).orThunk(getFallback));\n      return detailOption.map(detail => detail.element);\n    };\n    const rows = warehouse => {\n      const grid = warehouse.grid;\n      const rowsArr = range$1(grid.rows, identity);\n      const cols = range$1(grid.columns, identity);\n      return map$1(rowsArr, row => {\n        const getBlock = () => bind$2(cols, c => Warehouse.getAt(warehouse, row, c).filter(detail => detail.row === row).fold(constant([]), detail => [detail]));\n        const isSingle = detail => detail.rowspan === 1;\n        const getFallback = () => Warehouse.getAt(warehouse, row, 0);\n        return decide(getBlock, isSingle, getFallback);\n      });\n    };\n\n    const deduce = (xs, index) => {\n      if (index < 0 || index >= xs.length - 1) {\n        return Optional.none();\n      }\n      const current = xs[index].fold(() => {\n        const rest = reverse(xs.slice(0, index));\n        return findMap(rest, (a, i) => a.map(aa => ({\n          value: aa,\n          delta: i + 1\n        })));\n      }, c => Optional.some({\n        value: c,\n        delta: 0\n      }));\n      const next = xs[index + 1].fold(() => {\n        const rest = xs.slice(index + 1);\n        return findMap(rest, (a, i) => a.map(aa => ({\n          value: aa,\n          delta: i + 1\n        })));\n      }, n => Optional.some({\n        value: n,\n        delta: 1\n      }));\n      return current.bind(c => next.map(n => {\n        const extras = n.delta + c.delta;\n        return Math.abs(n.value - c.value) / extras;\n      }));\n    };\n\n    const onDirection = (isLtr, isRtl) => element => getDirection(element) === 'rtl' ? isRtl : isLtr;\n    const getDirection = element => get$a(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';\n\n    const api$1 = Dimension('height', element => {\n      const dom = element.dom;\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n    });\n    const get$8 = element => api$1.get(element);\n    const getOuter$1 = element => api$1.getOuter(element);\n    const getRuntime = getHeight$1;\n\n    const r = (left, top) => {\n      const translate = (x, y) => r(left + x, top + y);\n      return {\n        left,\n        top,\n        translate\n      };\n    };\n    const SugarPosition = r;\n\n    const boxPosition = dom => {\n      const box = dom.getBoundingClientRect();\n      return SugarPosition(box.left, box.top);\n    };\n    const firstDefinedOrZero = (a, b) => {\n      if (a !== undefined) {\n        return a;\n      } else {\n        return b !== undefined ? b : 0;\n      }\n    };\n    const absolute = element => {\n      const doc = element.dom.ownerDocument;\n      const body = doc.body;\n      const win = doc.defaultView;\n      const html = doc.documentElement;\n      if (body === element.dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n    };\n    const viewport = element => {\n      const dom = element.dom;\n      const doc = dom.ownerDocument;\n      const body = doc.body;\n      if (body === dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      if (!inBody(element)) {\n        return SugarPosition(0, 0);\n      }\n      return boxPosition(dom);\n    };\n\n    const rowInfo = (row, y) => ({\n      row,\n      y\n    });\n    const colInfo = (col, x) => ({\n      col,\n      x\n    });\n    const rtlEdge = cell => {\n      const pos = absolute(cell);\n      return pos.left + getOuter$2(cell);\n    };\n    const ltrEdge = cell => {\n      return absolute(cell).left;\n    };\n    const getLeftEdge = (index, cell) => {\n      return colInfo(index, ltrEdge(cell));\n    };\n    const getRightEdge = (index, cell) => {\n      return colInfo(index, rtlEdge(cell));\n    };\n    const getTop$1 = cell => {\n      return absolute(cell).top;\n    };\n    const getTopEdge = (index, cell) => {\n      return rowInfo(index, getTop$1(cell));\n    };\n    const getBottomEdge = (index, cell) => {\n      return rowInfo(index, getTop$1(cell) + getOuter$1(cell));\n    };\n    const findPositions = (getInnerEdge, getOuterEdge, array) => {\n      if (array.length === 0) {\n        return [];\n      }\n      const lines = map$1(array.slice(1), (cellOption, index) => {\n        return cellOption.map(cell => {\n          return getInnerEdge(index, cell);\n        });\n      });\n      const lastLine = array[array.length - 1].map(cell => {\n        return getOuterEdge(array.length - 1, cell);\n      });\n      return lines.concat([lastLine]);\n    };\n    const negate = step => {\n      return -step;\n    };\n    const height = {\n      delta: identity,\n      positions: optElements => findPositions(getTopEdge, getBottomEdge, optElements),\n      edge: getTop$1\n    };\n    const ltr$1 = {\n      delta: identity,\n      edge: ltrEdge,\n      positions: optElements => findPositions(getLeftEdge, getRightEdge, optElements)\n    };\n    const rtl$1 = {\n      delta: negate,\n      edge: rtlEdge,\n      positions: optElements => findPositions(getRightEdge, getLeftEdge, optElements)\n    };\n    const detect$1 = onDirection(ltr$1, rtl$1);\n    const width = {\n      delta: (amount, table) => detect$1(table).delta(amount, table),\n      positions: (cols, table) => detect$1(table).positions(cols, table),\n      edge: cell => detect$1(cell).edge(cell)\n    };\n\n    const units = {\n      unsupportedLength: [\n        'em',\n        'ex',\n        'cap',\n        'ch',\n        'ic',\n        'rem',\n        'lh',\n        'rlh',\n        'vw',\n        'vh',\n        'vi',\n        'vb',\n        'vmin',\n        'vmax',\n        'cm',\n        'mm',\n        'Q',\n        'in',\n        'pc',\n        'pt',\n        'px'\n      ],\n      fixed: [\n        'px',\n        'pt'\n      ],\n      relative: ['%'],\n      empty: ['']\n    };\n    const pattern = (() => {\n      const decimalDigits = '[0-9]+';\n      const signedInteger = '[+-]?' + decimalDigits;\n      const exponentPart = '[eE]' + signedInteger;\n      const dot = '\\\\.';\n      const opt = input => `(?:${ input })?`;\n      const unsignedDecimalLiteral = [\n        'Infinity',\n        decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),\n        dot + decimalDigits + opt(exponentPart),\n        decimalDigits + opt(exponentPart)\n      ].join('|');\n      const float = `[+-]?(?:${ unsignedDecimalLiteral })`;\n      return new RegExp(`^(${ float })(.*)$`);\n    })();\n    const isUnit = (unit, accepted) => exists(accepted, acc => exists(units[acc], check => unit === check));\n    const parse = (input, accepted) => {\n      const match = Optional.from(pattern.exec(input));\n      return match.bind(array => {\n        const value = Number(array[1]);\n        const unitRaw = array[2];\n        if (isUnit(unitRaw, accepted)) {\n          return Optional.some({\n            value,\n            unit: unitRaw\n          });\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n\n    const rPercentageBasedSizeRegex = /(\\d+(\\.\\d+)?)%/;\n    const rPixelBasedSizeRegex = /(\\d+(\\.\\d+)?)px|em/;\n    const isCol$2 = isTag('col');\n    const getPercentSize = (elm, outerGetter, innerGetter) => {\n      const relativeParent = parentElement(elm).getOrThunk(() => getBody$1(owner(elm)));\n      return outerGetter(elm) / innerGetter(relativeParent) * 100;\n    };\n    const setPixelWidth = (cell, amount) => {\n      set$1(cell, 'width', amount + 'px');\n    };\n    const setPercentageWidth = (cell, amount) => {\n      set$1(cell, 'width', amount + '%');\n    };\n    const setHeight = (cell, amount) => {\n      set$1(cell, 'height', amount + 'px');\n    };\n    const getHeightValue = cell => getRuntime(cell) + 'px';\n    const convert = (cell, number, getter, setter) => {\n      const newSize = table(cell).map(table => {\n        const total = getter(table);\n        return Math.floor(number / 100 * total);\n      }).getOr(number);\n      setter(cell, newSize);\n      return newSize;\n    };\n    const normalizePixelSize = (value, cell, getter, setter) => {\n      const number = parseFloat(value);\n      return endsWith(value, '%') && name(cell) !== 'table' ? convert(cell, number, getter, setter) : number;\n    };\n    const getTotalHeight = cell => {\n      const value = getHeightValue(cell);\n      if (!value) {\n        return get$8(cell);\n      }\n      return normalizePixelSize(value, cell, get$8, setHeight);\n    };\n    const get$7 = (cell, type, f) => {\n      const v = f(cell);\n      const span = getSpan(cell, type);\n      return v / span;\n    };\n    const getRaw$1 = (element, prop) => {\n      return getRaw$2(element, prop).orThunk(() => {\n        return getOpt(element, prop).map(val => val + 'px');\n      });\n    };\n    const getRawWidth$1 = element => getRaw$1(element, 'width');\n    const getRawHeight = element => getRaw$1(element, 'height');\n    const getPercentageWidth = cell => getPercentSize(cell, get$9, getInner);\n    const getPixelWidth$1 = cell => isCol$2(cell) ? get$9(cell) : getRuntime$1(cell);\n    const getHeight = cell => {\n      return get$7(cell, 'rowspan', getTotalHeight);\n    };\n    const getGenericWidth = cell => {\n      const width = getRawWidth$1(cell);\n      return width.bind(w => parse(w, [\n        'fixed',\n        'relative',\n        'empty'\n      ]));\n    };\n    const setGenericWidth = (cell, amount, unit) => {\n      set$1(cell, 'width', amount + unit);\n    };\n    const getPixelTableWidth = table => get$9(table) + 'px';\n    const getPercentTableWidth = table => getPercentSize(table, get$9, getInner) + '%';\n    const isPercentSizing$1 = table => getRawWidth$1(table).exists(size => rPercentageBasedSizeRegex.test(size));\n    const isPixelSizing$1 = table => getRawWidth$1(table).exists(size => rPixelBasedSizeRegex.test(size));\n    const isNoneSizing$1 = table => getRawWidth$1(table).isNone();\n    const percentageBasedSizeRegex = constant(rPercentageBasedSizeRegex);\n\n    const isCol$1 = isTag('col');\n    const getRawW = cell => {\n      return getRawWidth$1(cell).getOrThunk(() => getPixelWidth$1(cell) + 'px');\n    };\n    const getRawH = cell => {\n      return getRawHeight(cell).getOrThunk(() => getHeight(cell) + 'px');\n    };\n    const justCols = warehouse => map$1(Warehouse.justColumns(warehouse), column => Optional.from(column.element));\n    const isValidColumn = cell => {\n      const browser = detect$2().browser;\n      const supportsColWidths = browser.isChromium() || browser.isFirefox();\n      return isCol$1(cell) ? supportsColWidths : true;\n    };\n    const getDimension = (cellOpt, index, backups, filter, getter, fallback) => cellOpt.filter(filter).fold(() => fallback(deduce(backups, index)), cell => getter(cell));\n    const getWidthFrom = (warehouse, table, getWidth, fallback) => {\n      const columnCells = columns(warehouse);\n      const columns$1 = Warehouse.hasColumns(warehouse) ? justCols(warehouse) : columnCells;\n      const backups = [Optional.some(width.edge(table))].concat(map$1(width.positions(columnCells, table), pos => pos.map(p => p.x)));\n      const colFilter = not(hasColspan);\n      return map$1(columns$1, (cellOption, c) => {\n        return getDimension(cellOption, c, backups, colFilter, column => {\n          if (isValidColumn(column)) {\n            return getWidth(column);\n          } else {\n            const cell = bindFrom(columnCells[c], identity);\n            return getDimension(cell, c, backups, colFilter, cell => fallback(Optional.some(get$9(cell))), fallback);\n          }\n        }, fallback);\n      });\n    };\n    const getDeduced = deduced => {\n      return deduced.map(d => {\n        return d + 'px';\n      }).getOr('');\n    };\n    const getRawWidths = (warehouse, table) => {\n      return getWidthFrom(warehouse, table, getRawW, getDeduced);\n    };\n    const getPercentageWidths = (warehouse, table, tableSize) => {\n      return getWidthFrom(warehouse, table, getPercentageWidth, deduced => {\n        return deduced.fold(() => {\n          return tableSize.minCellWidth();\n        }, cellWidth => {\n          return cellWidth / tableSize.pixelWidth() * 100;\n        });\n      });\n    };\n    const getPixelWidths = (warehouse, table, tableSize) => {\n      return getWidthFrom(warehouse, table, getPixelWidth$1, deduced => {\n        return deduced.getOrThunk(tableSize.minCellWidth);\n      });\n    };\n    const getHeightFrom = (warehouse, table, direction, getHeight, fallback) => {\n      const rows$1 = rows(warehouse);\n      const backups = [Optional.some(direction.edge(table))].concat(map$1(direction.positions(rows$1, table), pos => pos.map(p => p.y)));\n      return map$1(rows$1, (cellOption, c) => {\n        return getDimension(cellOption, c, backups, not(hasRowspan), getHeight, fallback);\n      });\n    };\n    const getPixelHeights = (warehouse, table, direction) => {\n      return getHeightFrom(warehouse, table, direction, getHeight, deduced => {\n        return deduced.getOrThunk(minHeight);\n      });\n    };\n    const getRawHeights = (warehouse, table, direction) => {\n      return getHeightFrom(warehouse, table, direction, getRawH, getDeduced);\n    };\n\n    const widthLookup = (table, getter) => () => {\n      if (inBody(table)) {\n        return getter(table);\n      } else {\n        return parseFloat(getRaw$2(table, 'width').getOr('0'));\n      }\n    };\n    const noneSize = table => {\n      const getWidth = widthLookup(table, get$9);\n      const zero = constant(0);\n      const getWidths = (warehouse, tableSize) => getPixelWidths(warehouse, table, tableSize);\n      return {\n        width: getWidth,\n        pixelWidth: getWidth,\n        getWidths,\n        getCellDelta: zero,\n        singleColumnWidth: constant([0]),\n        minCellWidth: zero,\n        setElementWidth: noop,\n        adjustTableWidth: noop,\n        isRelative: true,\n        label: 'none'\n      };\n    };\n    const percentageSize = table => {\n      const getFloatWidth = widthLookup(table, elem => parseFloat(getPercentTableWidth(elem)));\n      const getWidth = widthLookup(table, get$9);\n      const getCellDelta = delta => delta / getWidth() * 100;\n      const singleColumnWidth = (w, _delta) => [100 - w];\n      const minCellWidth = () => minWidth() / getWidth() * 100;\n      const adjustTableWidth = delta => {\n        const currentWidth = getFloatWidth();\n        const change = delta / 100 * currentWidth;\n        const newWidth = currentWidth + change;\n        setPercentageWidth(table, newWidth);\n      };\n      const getWidths = (warehouse, tableSize) => getPercentageWidths(warehouse, table, tableSize);\n      return {\n        width: getFloatWidth,\n        pixelWidth: getWidth,\n        getWidths,\n        getCellDelta,\n        singleColumnWidth,\n        minCellWidth,\n        setElementWidth: setPercentageWidth,\n        adjustTableWidth,\n        isRelative: true,\n        label: 'percent'\n      };\n    };\n    const pixelSize = table => {\n      const getWidth = widthLookup(table, get$9);\n      const getCellDelta = identity;\n      const singleColumnWidth = (w, delta) => {\n        const newNext = Math.max(minWidth(), w + delta);\n        return [newNext - w];\n      };\n      const adjustTableWidth = delta => {\n        const newWidth = getWidth() + delta;\n        setPixelWidth(table, newWidth);\n      };\n      const getWidths = (warehouse, tableSize) => getPixelWidths(warehouse, table, tableSize);\n      return {\n        width: getWidth,\n        pixelWidth: getWidth,\n        getWidths,\n        getCellDelta,\n        singleColumnWidth,\n        minCellWidth: minWidth,\n        setElementWidth: setPixelWidth,\n        adjustTableWidth,\n        isRelative: false,\n        label: 'pixel'\n      };\n    };\n    const chooseSize = (element, width) => {\n      const percentMatch = percentageBasedSizeRegex().exec(width);\n      if (percentMatch !== null) {\n        return percentageSize(element);\n      } else {\n        return pixelSize(element);\n      }\n    };\n    const getTableSize = table => {\n      const width = getRawWidth$1(table);\n      return width.fold(() => noneSize(table), w => chooseSize(table, w));\n    };\n    const TableSize = {\n      getTableSize,\n      pixelSize,\n      percentageSize,\n      noneSize\n    };\n\n    const statsStruct = (minRow, minCol, maxRow, maxCol, allCells, selectedCells) => ({\n      minRow,\n      minCol,\n      maxRow,\n      maxCol,\n      allCells,\n      selectedCells\n    });\n    const findSelectedStats = (house, isSelected) => {\n      const totalColumns = house.grid.columns;\n      const totalRows = house.grid.rows;\n      let minRow = totalRows;\n      let minCol = totalColumns;\n      let maxRow = 0;\n      let maxCol = 0;\n      const allCells = [];\n      const selectedCells = [];\n      each$1(house.access, detail => {\n        allCells.push(detail);\n        if (isSelected(detail)) {\n          selectedCells.push(detail);\n          const startRow = detail.row;\n          const endRow = startRow + detail.rowspan - 1;\n          const startCol = detail.column;\n          const endCol = startCol + detail.colspan - 1;\n          if (startRow < minRow) {\n            minRow = startRow;\n          } else if (endRow > maxRow) {\n            maxRow = endRow;\n          }\n          if (startCol < minCol) {\n            minCol = startCol;\n          } else if (endCol > maxCol) {\n            maxCol = endCol;\n          }\n        }\n      });\n      return statsStruct(minRow, minCol, maxRow, maxCol, allCells, selectedCells);\n    };\n    const makeCell = (list, seenSelected, rowIndex) => {\n      const row = list[rowIndex].element;\n      const td = SugarElement.fromTag('td');\n      append$1(td, SugarElement.fromTag('br'));\n      const f = seenSelected ? append$1 : prepend;\n      f(row, td);\n    };\n    const fillInGaps = (list, house, stats, isSelected) => {\n      const rows = filter$2(list, row => row.section !== 'colgroup');\n      const totalColumns = house.grid.columns;\n      const totalRows = house.grid.rows;\n      for (let i = 0; i < totalRows; i++) {\n        let seenSelected = false;\n        for (let j = 0; j < totalColumns; j++) {\n          if (!(i < stats.minRow || i > stats.maxRow || j < stats.minCol || j > stats.maxCol)) {\n            const needCell = Warehouse.getAt(house, i, j).filter(isSelected).isNone();\n            if (needCell) {\n              makeCell(rows, seenSelected, i);\n            } else {\n              seenSelected = true;\n            }\n          }\n        }\n      }\n    };\n    const clean = (replica, stats, house, widthDelta) => {\n      each$1(house.columns, col => {\n        if (col.column < stats.minCol || col.column > stats.maxCol) {\n          remove$6(col.element);\n        }\n      });\n      const emptyRows = filter$2(firstLayer(replica, 'tr'), row => row.dom.childElementCount === 0);\n      each$2(emptyRows, remove$6);\n      if (stats.minCol === stats.maxCol || stats.minRow === stats.maxRow) {\n        each$2(firstLayer(replica, 'th,td'), cell => {\n          remove$7(cell, 'rowspan');\n          remove$7(cell, 'colspan');\n        });\n      }\n      remove$7(replica, LOCKED_COL_ATTR);\n      remove$7(replica, 'data-snooker-col-series');\n      const tableSize = TableSize.getTableSize(replica);\n      tableSize.adjustTableWidth(widthDelta);\n    };\n    const getTableWidthDelta = (table, warehouse, tableSize, stats) => {\n      if (stats.minCol === 0 && warehouse.grid.columns === stats.maxCol + 1) {\n        return 0;\n      }\n      const colWidths = getPixelWidths(warehouse, table, tableSize);\n      const allColsWidth = foldl(colWidths, (acc, width) => acc + width, 0);\n      const selectedColsWidth = foldl(colWidths.slice(stats.minCol, stats.maxCol + 1), (acc, width) => acc + width, 0);\n      const newWidth = selectedColsWidth / allColsWidth * tableSize.pixelWidth();\n      const delta = newWidth - tableSize.pixelWidth();\n      return tableSize.getCellDelta(delta);\n    };\n    const extract$1 = (table, selectedSelector) => {\n      const isSelected = detail => is$2(detail.element, selectedSelector);\n      const replica = deep(table);\n      const list = fromTable$1(replica);\n      const tableSize = TableSize.getTableSize(table);\n      const replicaHouse = Warehouse.generate(list);\n      const replicaStats = findSelectedStats(replicaHouse, isSelected);\n      const selector = 'th:not(' + selectedSelector + ')' + ',td:not(' + selectedSelector + ')';\n      const unselectedCells = filterFirstLayer(replica, 'th,td', cell => is$2(cell, selector));\n      each$2(unselectedCells, remove$6);\n      fillInGaps(list, replicaHouse, replicaStats, isSelected);\n      const house = Warehouse.fromTable(table);\n      const widthDelta = getTableWidthDelta(table, house, tableSize, replicaStats);\n      clean(replica, replicaStats, replicaHouse, widthDelta);\n      return replica;\n    };\n\n    const nbsp = '\\xA0';\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api = NodeValue(isText, 'text');\n    const get$6 = element => api.get(element);\n    const getOption = element => api.getOption(element);\n    const set = (element, value) => api.set(element, value);\n\n    const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children$2(element).length, v => v.length);\n    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n    const elementsWithCursorPosition = [\n      'img',\n      'br'\n    ];\n    const isCursorPosition = elem => {\n      const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem));\n    };\n\n    const first = element => descendant$1(element, isCursorPosition);\n    const last$1 = element => descendantRtl(element, isCursorPosition);\n    const descendantRtl = (scope, predicate) => {\n      const descend = element => {\n        const children = children$2(element);\n        for (let i = children.length - 1; i >= 0; i--) {\n          const child = children[i];\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(child);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope);\n    };\n\n    const transferableAttributes = {\n      scope: [\n        'row',\n        'col'\n      ]\n    };\n    const createCell = doc => () => {\n      const td = SugarElement.fromTag('td', doc.dom);\n      append$1(td, SugarElement.fromTag('br', doc.dom));\n      return td;\n    };\n    const createCol = doc => () => {\n      return SugarElement.fromTag('col', doc.dom);\n    };\n    const createColgroup = doc => () => {\n      return SugarElement.fromTag('colgroup', doc.dom);\n    };\n    const createRow$1 = doc => () => {\n      return SugarElement.fromTag('tr', doc.dom);\n    };\n    const replace$1 = (cell, tag, attrs) => {\n      const replica = copy$2(cell, tag);\n      each$1(attrs, (v, k) => {\n        if (v === null) {\n          remove$7(replica, k);\n        } else {\n          set$2(replica, k, v);\n        }\n      });\n      return replica;\n    };\n    const pasteReplace = cell => {\n      return cell;\n    };\n    const cloneFormats = (oldCell, newCell, formats) => {\n      const first$1 = first(oldCell);\n      return first$1.map(firstText => {\n        const formatSelector = formats.join(',');\n        const parents = ancestors$3(firstText, formatSelector, element => {\n          return eq$1(element, oldCell);\n        });\n        return foldr(parents, (last, parent) => {\n          const clonedFormat = shallow(parent);\n          remove$7(clonedFormat, 'contenteditable');\n          append$1(last, clonedFormat);\n          return clonedFormat;\n        }, newCell);\n      }).getOr(newCell);\n    };\n    const cloneAppropriateAttributes = (original, clone) => {\n      each$1(transferableAttributes, (validAttributes, attributeName) => getOpt(original, attributeName).filter(attribute => contains$2(validAttributes, attribute)).each(attribute => set$2(clone, attributeName, attribute)));\n    };\n    const cellOperations = (mutate, doc, formatsToClone) => {\n      const cloneCss = (prev, clone) => {\n        copy$1(prev.element, clone);\n        remove$5(clone, 'height');\n        if (prev.colspan !== 1) {\n          remove$5(clone, 'width');\n        }\n      };\n      const newCell = prev => {\n        const td = SugarElement.fromTag(name(prev.element), doc.dom);\n        const formats = formatsToClone.getOr([\n          'strong',\n          'em',\n          'b',\n          'i',\n          'span',\n          'font',\n          'h1',\n          'h2',\n          'h3',\n          'h4',\n          'h5',\n          'h6',\n          'p',\n          'div'\n        ]);\n        const lastNode = formats.length > 0 ? cloneFormats(prev.element, td, formats) : td;\n        append$1(lastNode, SugarElement.fromTag('br'));\n        cloneCss(prev, td);\n        cloneAppropriateAttributes(prev.element, td);\n        mutate(prev.element, td);\n        return td;\n      };\n      const newCol = prev => {\n        const col = SugarElement.fromTag(name(prev.element), doc.dom);\n        cloneCss(prev, col);\n        mutate(prev.element, col);\n        return col;\n      };\n      return {\n        col: newCol,\n        colgroup: createColgroup(doc),\n        row: createRow$1(doc),\n        cell: newCell,\n        replace: replace$1,\n        colGap: createCol(doc),\n        gap: createCell(doc)\n      };\n    };\n    const paste$1 = doc => {\n      return {\n        col: createCol(doc),\n        colgroup: createColgroup(doc),\n        row: createRow$1(doc),\n        cell: createCell(doc),\n        replace: pasteReplace,\n        colGap: createCol(doc),\n        gap: createCell(doc)\n      };\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      return children$2(SugarElement.fromDom(div));\n    };\n    const fromDom = nodes => map$1(nodes, SugarElement.fromDom);\n\n    const getBody = editor => SugarElement.fromDom(editor.getBody());\n    const getIsRoot = editor => element => eq$1(element, getBody(editor));\n    const removeDataStyle = table => {\n      remove$7(table, 'data-mce-style');\n      const removeStyleAttribute = element => remove$7(element, 'data-mce-style');\n      each$2(cells$1(table), removeStyleAttribute);\n      each$2(columns$1(table), removeStyleAttribute);\n      each$2(rows$1(table), removeStyleAttribute);\n    };\n    const getSelectionStart = editor => SugarElement.fromDom(editor.selection.getStart());\n    const getPixelWidth = elm => elm.getBoundingClientRect().width;\n    const getPixelHeight = elm => elm.getBoundingClientRect().height;\n    const getRawWidth = (editor, elm) => {\n      const raw = editor.dom.getStyle(elm, 'width') || editor.dom.getAttrib(elm, 'width');\n      return Optional.from(raw).filter(isNotEmpty);\n    };\n    const isPercentage$1 = value => /^(\\d+(\\.\\d+)?)%$/.test(value);\n    const isPixel = value => /^(\\d+(\\.\\d+)?)px$/.test(value);\n\n    const inSelection = (bounds, detail) => {\n      const leftEdge = detail.column;\n      const rightEdge = detail.column + detail.colspan - 1;\n      const topEdge = detail.row;\n      const bottomEdge = detail.row + detail.rowspan - 1;\n      return leftEdge <= bounds.finishCol && rightEdge >= bounds.startCol && (topEdge <= bounds.finishRow && bottomEdge >= bounds.startRow);\n    };\n    const isWithin = (bounds, detail) => {\n      return detail.column >= bounds.startCol && detail.column + detail.colspan - 1 <= bounds.finishCol && detail.row >= bounds.startRow && detail.row + detail.rowspan - 1 <= bounds.finishRow;\n    };\n    const isRectangular = (warehouse, bounds) => {\n      let isRect = true;\n      const detailIsWithin = curry(isWithin, bounds);\n      for (let i = bounds.startRow; i <= bounds.finishRow; i++) {\n        for (let j = bounds.startCol; j <= bounds.finishCol; j++) {\n          isRect = isRect && Warehouse.getAt(warehouse, i, j).exists(detailIsWithin);\n        }\n      }\n      return isRect ? Optional.some(bounds) : Optional.none();\n    };\n\n    const getBounds = (detailA, detailB) => {\n      return bounds(Math.min(detailA.row, detailB.row), Math.min(detailA.column, detailB.column), Math.max(detailA.row + detailA.rowspan - 1, detailB.row + detailB.rowspan - 1), Math.max(detailA.column + detailA.colspan - 1, detailB.column + detailB.colspan - 1));\n    };\n    const getAnyBox = (warehouse, startCell, finishCell) => {\n      const startCoords = Warehouse.findItem(warehouse, startCell, eq$1);\n      const finishCoords = Warehouse.findItem(warehouse, finishCell, eq$1);\n      return startCoords.bind(sc => {\n        return finishCoords.map(fc => {\n          return getBounds(sc, fc);\n        });\n      });\n    };\n    const getBox$1 = (warehouse, startCell, finishCell) => {\n      return getAnyBox(warehouse, startCell, finishCell).bind(bounds => {\n        return isRectangular(warehouse, bounds);\n      });\n    };\n\n    const moveBy$1 = (warehouse, cell, row, column) => {\n      return Warehouse.findItem(warehouse, cell, eq$1).bind(detail => {\n        const startRow = row > 0 ? detail.row + detail.rowspan - 1 : detail.row;\n        const startCol = column > 0 ? detail.column + detail.colspan - 1 : detail.column;\n        const dest = Warehouse.getAt(warehouse, startRow + row, startCol + column);\n        return dest.map(d => {\n          return d.element;\n        });\n      });\n    };\n    const intercepts$1 = (warehouse, start, finish) => {\n      return getAnyBox(warehouse, start, finish).map(bounds => {\n        const inside = Warehouse.filterItems(warehouse, curry(inSelection, bounds));\n        return map$1(inside, detail => {\n          return detail.element;\n        });\n      });\n    };\n    const parentCell = (warehouse, innerCell) => {\n      const isContainedBy = (c1, c2) => {\n        return contains$1(c2, c1);\n      };\n      return Warehouse.findItem(warehouse, innerCell, isContainedBy).map(detail => {\n        return detail.element;\n      });\n    };\n\n    const moveBy = (cell, deltaRow, deltaColumn) => {\n      return table(cell).bind(table => {\n        const warehouse = getWarehouse(table);\n        return moveBy$1(warehouse, cell, deltaRow, deltaColumn);\n      });\n    };\n    const intercepts = (table, first, last) => {\n      const warehouse = getWarehouse(table);\n      return intercepts$1(warehouse, first, last);\n    };\n    const nestedIntercepts = (table, first, firstTable, last, lastTable) => {\n      const warehouse = getWarehouse(table);\n      const optStartCell = eq$1(table, firstTable) ? Optional.some(first) : parentCell(warehouse, first);\n      const optLastCell = eq$1(table, lastTable) ? Optional.some(last) : parentCell(warehouse, last);\n      return optStartCell.bind(startCell => optLastCell.bind(lastCell => intercepts$1(warehouse, startCell, lastCell)));\n    };\n    const getBox = (table, first, last) => {\n      const warehouse = getWarehouse(table);\n      return getBox$1(warehouse, first, last);\n    };\n    const getWarehouse = Warehouse.fromTable;\n\n    var TagBoundaries = [\n      'body',\n      'p',\n      'div',\n      'article',\n      'aside',\n      'figcaption',\n      'figure',\n      'footer',\n      'header',\n      'nav',\n      'section',\n      'ol',\n      'ul',\n      'li',\n      'table',\n      'thead',\n      'tbody',\n      'tfoot',\n      'caption',\n      'tr',\n      'td',\n      'th',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'blockquote',\n      'pre',\n      'address'\n    ];\n\n    var DomUniverse = () => {\n      const clone = element => {\n        return SugarElement.fromDom(element.dom.cloneNode(false));\n      };\n      const document = element => documentOrOwner(element).dom;\n      const isBoundary = element => {\n        if (!isElement(element)) {\n          return false;\n        }\n        if (name(element) === 'body') {\n          return true;\n        }\n        return contains$2(TagBoundaries, name(element));\n      };\n      const isEmptyTag = element => {\n        if (!isElement(element)) {\n          return false;\n        }\n        return contains$2([\n          'br',\n          'img',\n          'hr',\n          'input'\n        ], name(element));\n      };\n      const isNonEditable = element => isElement(element) && get$b(element, 'contenteditable') === 'false';\n      const comparePosition = (element, other) => {\n        return element.dom.compareDocumentPosition(other.dom);\n      };\n      const copyAttributesTo = (source, destination) => {\n        const as = clone$2(source);\n        setAll$1(destination, as);\n      };\n      const isSpecial = element => {\n        const tag = name(element);\n        return contains$2([\n          'script',\n          'noscript',\n          'iframe',\n          'noframes',\n          'noembed',\n          'title',\n          'style',\n          'textarea',\n          'xmp'\n        ], tag);\n      };\n      const getLanguage = element => isElement(element) ? getOpt(element, 'lang') : Optional.none();\n      return {\n        up: constant({\n          selector: ancestor$1,\n          closest: closest$1,\n          predicate: ancestor$2,\n          all: parents\n        }),\n        down: constant({\n          selector: descendants,\n          predicate: descendants$1\n        }),\n        styles: constant({\n          get: get$a,\n          getRaw: getRaw$2,\n          set: set$1,\n          remove: remove$5\n        }),\n        attrs: constant({\n          get: get$b,\n          set: set$2,\n          remove: remove$7,\n          copyTo: copyAttributesTo\n        }),\n        insert: constant({\n          before: before$3,\n          after: after$5,\n          afterAll: after$4,\n          append: append$1,\n          appendAll: append,\n          prepend: prepend,\n          wrap: wrap\n        }),\n        remove: constant({\n          unwrap: unwrap,\n          remove: remove$6\n        }),\n        create: constant({\n          nu: SugarElement.fromTag,\n          clone,\n          text: SugarElement.fromText\n        }),\n        query: constant({\n          comparePosition,\n          prevSibling: prevSibling,\n          nextSibling: nextSibling\n        }),\n        property: constant({\n          children: children$2,\n          name: name,\n          parent: parent,\n          document,\n          isText: isText,\n          isComment: isComment,\n          isElement: isElement,\n          isSpecial,\n          getLanguage,\n          getText: get$6,\n          setText: set,\n          isBoundary,\n          isEmptyTag,\n          isNonEditable\n        }),\n        eq: eq$1,\n        is: is$1\n      };\n    };\n\n    const all = (universe, look, elements, f) => {\n      const head = elements[0];\n      const tail = elements.slice(1);\n      return f(universe, look, head, tail);\n    };\n    const oneAll = (universe, look, elements) => {\n      return elements.length > 0 ? all(universe, look, elements, unsafeOne) : Optional.none();\n    };\n    const unsafeOne = (universe, look, head, tail) => {\n      const start = look(universe, head);\n      return foldr(tail, (b, a) => {\n        const current = look(universe, a);\n        return commonElement(universe, b, current);\n      }, start);\n    };\n    const commonElement = (universe, start, end) => {\n      return start.bind(s => {\n        return end.filter(curry(universe.eq, s));\n      });\n    };\n\n    const eq = (universe, item) => {\n      return curry(universe.eq, item);\n    };\n    const ancestors$2 = (universe, start, end, isRoot = never) => {\n      const ps1 = [start].concat(universe.up().all(start));\n      const ps2 = [end].concat(universe.up().all(end));\n      const prune = path => {\n        const index = findIndex(path, isRoot);\n        return index.fold(() => {\n          return path;\n        }, ind => {\n          return path.slice(0, ind + 1);\n        });\n      };\n      const pruned1 = prune(ps1);\n      const pruned2 = prune(ps2);\n      const shared = find$1(pruned1, x => {\n        return exists(pruned2, eq(universe, x));\n      });\n      return {\n        firstpath: pruned1,\n        secondpath: pruned2,\n        shared\n      };\n    };\n\n    const sharedOne$1 = oneAll;\n    const ancestors$1 = ancestors$2;\n\n    const universe$3 = DomUniverse();\n    const sharedOne = (look, elements) => {\n      return sharedOne$1(universe$3, (_universe, element) => {\n        return look(element);\n      }, elements);\n    };\n    const ancestors = (start, finish, isRoot) => {\n      return ancestors$1(universe$3, start, finish, isRoot);\n    };\n\n    const lookupTable = container => {\n      return ancestor$1(container, 'table');\n    };\n    const identify = (start, finish, isRoot) => {\n      const getIsRoot = rootTable => {\n        return element => {\n          return isRoot !== undefined && isRoot(element) || eq$1(element, rootTable);\n        };\n      };\n      if (eq$1(start, finish)) {\n        return Optional.some({\n          boxes: Optional.some([start]),\n          start,\n          finish\n        });\n      } else {\n        return lookupTable(start).bind(startTable => {\n          return lookupTable(finish).bind(finishTable => {\n            if (eq$1(startTable, finishTable)) {\n              return Optional.some({\n                boxes: intercepts(startTable, start, finish),\n                start,\n                finish\n              });\n            } else if (contains$1(startTable, finishTable)) {\n              const ancestorCells = ancestors$3(finish, 'td,th', getIsRoot(startTable));\n              const finishCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : finish;\n              return Optional.some({\n                boxes: nestedIntercepts(startTable, start, startTable, finish, finishTable),\n                start,\n                finish: finishCell\n              });\n            } else if (contains$1(finishTable, startTable)) {\n              const ancestorCells = ancestors$3(start, 'td,th', getIsRoot(finishTable));\n              const startCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : start;\n              return Optional.some({\n                boxes: nestedIntercepts(finishTable, start, startTable, finish, finishTable),\n                start,\n                finish: startCell\n              });\n            } else {\n              return ancestors(start, finish).shared.bind(lca => {\n                return closest$1(lca, 'table', isRoot).bind(lcaTable => {\n                  const finishAncestorCells = ancestors$3(finish, 'td,th', getIsRoot(lcaTable));\n                  const finishCell = finishAncestorCells.length > 0 ? finishAncestorCells[finishAncestorCells.length - 1] : finish;\n                  const startAncestorCells = ancestors$3(start, 'td,th', getIsRoot(lcaTable));\n                  const startCell = startAncestorCells.length > 0 ? startAncestorCells[startAncestorCells.length - 1] : start;\n                  return Optional.some({\n                    boxes: nestedIntercepts(lcaTable, start, startTable, finish, finishTable),\n                    start: startCell,\n                    finish: finishCell\n                  });\n                });\n              });\n            }\n          });\n        });\n      }\n    };\n    const retrieve$1 = (container, selector) => {\n      const sels = descendants(container, selector);\n      return sels.length > 0 ? Optional.some(sels) : Optional.none();\n    };\n    const getLast = (boxes, lastSelectedSelector) => {\n      return find$1(boxes, box => {\n        return is$2(box, lastSelectedSelector);\n      });\n    };\n    const getEdges = (container, firstSelectedSelector, lastSelectedSelector) => {\n      return descendant(container, firstSelectedSelector).bind(first => {\n        return descendant(container, lastSelectedSelector).bind(last => {\n          return sharedOne(lookupTable, [\n            first,\n            last\n          ]).map(table => {\n            return {\n              first,\n              last,\n              table\n            };\n          });\n        });\n      });\n    };\n    const expandTo = (finish, firstSelectedSelector) => {\n      return ancestor$1(finish, 'table').bind(table => {\n        return descendant(table, firstSelectedSelector).bind(start => {\n          return identify(start, finish).bind(identified => {\n            return identified.boxes.map(boxes => {\n              return {\n                boxes,\n                start: identified.start,\n                finish: identified.finish\n              };\n            });\n          });\n        });\n      });\n    };\n    const shiftSelection = (boxes, deltaRow, deltaColumn, firstSelectedSelector, lastSelectedSelector) => {\n      return getLast(boxes, lastSelectedSelector).bind(last => {\n        return moveBy(last, deltaRow, deltaColumn).bind(finish => {\n          return expandTo(finish, firstSelectedSelector);\n        });\n      });\n    };\n\n    const retrieve = (container, selector) => {\n      return retrieve$1(container, selector);\n    };\n    const retrieveBox = (container, firstSelectedSelector, lastSelectedSelector) => {\n      return getEdges(container, firstSelectedSelector, lastSelectedSelector).bind(edges => {\n        const isRoot = ancestor => {\n          return eq$1(container, ancestor);\n        };\n        const sectionSelector = 'thead,tfoot,tbody,table';\n        const firstAncestor = ancestor$1(edges.first, sectionSelector, isRoot);\n        const lastAncestor = ancestor$1(edges.last, sectionSelector, isRoot);\n        return firstAncestor.bind(fA => {\n          return lastAncestor.bind(lA => {\n            return eq$1(fA, lA) ? getBox(edges.table, edges.first, edges.last) : Optional.none();\n          });\n        });\n      });\n    };\n\n    const selection = identity;\n    const unmergable = selectedCells => {\n      const hasSpan = (elem, type) => getOpt(elem, type).exists(span => parseInt(span, 10) > 1);\n      const hasRowOrColSpan = elem => hasSpan(elem, 'rowspan') || hasSpan(elem, 'colspan');\n      return selectedCells.length > 0 && forall(selectedCells, hasRowOrColSpan) ? Optional.some(selectedCells) : Optional.none();\n    };\n    const mergable = (table, selectedCells, ephemera) => {\n      if (selectedCells.length <= 1) {\n        return Optional.none();\n      } else {\n        return retrieveBox(table, ephemera.firstSelectedSelector, ephemera.lastSelectedSelector).map(bounds => ({\n          bounds,\n          cells: selectedCells\n        }));\n      }\n    };\n\n    const strSelected = 'data-mce-selected';\n    const strSelectedSelector = 'td[' + strSelected + '],th[' + strSelected + ']';\n    const strAttributeSelector = '[' + strSelected + ']';\n    const strFirstSelected = 'data-mce-first-selected';\n    const strFirstSelectedSelector = 'td[' + strFirstSelected + '],th[' + strFirstSelected + ']';\n    const strLastSelected = 'data-mce-last-selected';\n    const strLastSelectedSelector = 'td[' + strLastSelected + '],th[' + strLastSelected + ']';\n    const attributeSelector = strAttributeSelector;\n    const ephemera = {\n      selected: strSelected,\n      selectedSelector: strSelectedSelector,\n      firstSelected: strFirstSelected,\n      firstSelectedSelector: strFirstSelectedSelector,\n      lastSelected: strLastSelected,\n      lastSelectedSelector: strLastSelectedSelector\n    };\n\n    const forMenu = (selectedCells, table, cell) => ({\n      element: cell,\n      mergable: mergable(table, selectedCells, ephemera),\n      unmergable: unmergable(selectedCells),\n      selection: selection(selectedCells)\n    });\n    const paste = (element, clipboard, generators) => ({\n      element,\n      clipboard,\n      generators\n    });\n    const pasteRows = (selectedCells, _cell, clipboard, generators) => ({\n      selection: selection(selectedCells),\n      clipboard,\n      generators\n    });\n\n    const getSelectionCellFallback = element => table(element).bind(table => retrieve(table, ephemera.firstSelectedSelector)).fold(constant(element), cells => cells[0]);\n    const getSelectionFromSelector = selector => (initCell, isRoot) => {\n      const cellName = name(initCell);\n      const cell = cellName === 'col' || cellName === 'colgroup' ? getSelectionCellFallback(initCell) : initCell;\n      return closest$1(cell, selector, isRoot);\n    };\n    const getSelectionCellOrCaption = getSelectionFromSelector('th,td,caption');\n    const getSelectionCell = getSelectionFromSelector('th,td');\n    const getCellsFromSelection = editor => fromDom(editor.model.table.getSelectedCells());\n    const getCellsFromFakeSelection = editor => filter$2(getCellsFromSelection(editor), cell => is$2(cell, ephemera.selectedSelector));\n\n    const extractSelected = cells => {\n      return table(cells[0]).map(table => {\n        const replica = extract$1(table, attributeSelector);\n        removeDataStyle(replica);\n        return [replica];\n      });\n    };\n    const serializeElements = (editor, elements) => map$1(elements, elm => editor.selection.serializer.serialize(elm.dom, {})).join('');\n    const getTextContent = elements => map$1(elements, element => element.dom.innerText).join('');\n    const registerEvents = (editor, actions) => {\n      editor.on('BeforeGetContent', e => {\n        const multiCellContext = cells => {\n          e.preventDefault();\n          extractSelected(cells).each(elements => {\n            e.content = e.format === 'text' ? getTextContent(elements) : serializeElements(editor, elements);\n          });\n        };\n        if (e.selection === true) {\n          const cells = getCellsFromFakeSelection(editor);\n          if (cells.length >= 1) {\n            multiCellContext(cells);\n          }\n        }\n      });\n      editor.on('BeforeSetContent', e => {\n        if (e.selection === true && e.paste === true) {\n          const selectedCells = getCellsFromSelection(editor);\n          head(selectedCells).each(cell => {\n            table(cell).each(table => {\n              const elements = filter$2(fromHtml(e.content), content => {\n                return name(content) !== 'meta';\n              });\n              const isTable = isTag('table');\n              if (elements.length === 1 && isTable(elements[0])) {\n                e.preventDefault();\n                const doc = SugarElement.fromDom(editor.getDoc());\n                const generators = paste$1(doc);\n                const targets = paste(cell, elements[0], generators);\n                actions.pasteCells(table, targets).each(() => {\n                  editor.focus();\n                });\n              }\n            });\n          });\n        }\n      });\n    };\n\n    const point = (element, offset) => ({\n      element,\n      offset\n    });\n\n    const scan$1 = (universe, element, direction) => {\n      if (universe.property().isText(element) && universe.property().getText(element).trim().length === 0 || universe.property().isComment(element)) {\n        return direction(element).bind(elem => {\n          return scan$1(universe, elem, direction).orThunk(() => {\n            return Optional.some(elem);\n          });\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const toEnd = (universe, element) => {\n      if (universe.property().isText(element)) {\n        return universe.property().getText(element).length;\n      }\n      const children = universe.property().children(element);\n      return children.length;\n    };\n    const freefallRtl$2 = (universe, element) => {\n      const candidate = scan$1(universe, element, universe.query().prevSibling).getOr(element);\n      if (universe.property().isText(candidate)) {\n        return point(candidate, toEnd(universe, candidate));\n      }\n      const children = universe.property().children(candidate);\n      return children.length > 0 ? freefallRtl$2(universe, children[children.length - 1]) : point(candidate, toEnd(universe, candidate));\n    };\n\n    const freefallRtl$1 = freefallRtl$2;\n\n    const universe$2 = DomUniverse();\n    const freefallRtl = element => {\n      return freefallRtl$1(universe$2, element);\n    };\n\n    const halve = (main, other) => {\n      if (!hasColspan(main)) {\n        const width = getGenericWidth(main);\n        width.each(w => {\n          const newWidth = w.value / 2;\n          setGenericWidth(main, newWidth, w.unit);\n          setGenericWidth(other, newWidth, w.unit);\n        });\n      }\n    };\n\n    const zero = array => map$1(array, constant(0));\n    const surround = (sizes, startIndex, endIndex, results, f) => f(sizes.slice(0, startIndex)).concat(results).concat(f(sizes.slice(endIndex)));\n    const clampDeltaHelper = predicate => (sizes, index, delta, minCellSize) => {\n      if (!predicate(delta)) {\n        return delta;\n      } else {\n        const newSize = Math.max(minCellSize, sizes[index] - Math.abs(delta));\n        const diff = Math.abs(newSize - sizes[index]);\n        return delta >= 0 ? diff : -diff;\n      }\n    };\n    const clampNegativeDelta = clampDeltaHelper(delta => delta < 0);\n    const clampDelta = clampDeltaHelper(always);\n    const resizeTable = () => {\n      const calcFixedDeltas = (sizes, index, next, delta, minCellSize) => {\n        const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);\n        return surround(sizes, index, next + 1, [\n          clampedDelta,\n          0\n        ], zero);\n      };\n      const calcRelativeDeltas = (sizes, index, delta, minCellSize) => {\n        const ratio = (100 + delta) / 100;\n        const newThis = Math.max(minCellSize, (sizes[index] + delta) / ratio);\n        return map$1(sizes, (size, idx) => {\n          const newSize = idx === index ? newThis : size / ratio;\n          return newSize - size;\n        });\n      };\n      const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize, isRelative) => {\n        if (isRelative) {\n          return calcRelativeDeltas(sizes, index, delta, minCellSize);\n        } else {\n          return calcFixedDeltas(sizes, index, next, delta, minCellSize);\n        }\n      };\n      const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize, isRelative) => calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize, isRelative);\n      const resizeTable = (resizer, delta) => resizer(delta);\n      const calcRightEdgeDeltas = (sizes, _prev, index, delta, minCellSize, isRelative) => {\n        if (isRelative) {\n          return calcRelativeDeltas(sizes, index, delta, minCellSize);\n        } else {\n          const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);\n          return zero(sizes.slice(0, index)).concat([clampedDelta]);\n        }\n      };\n      const calcRedestributedWidths = (sizes, totalWidth, pixelDelta, isRelative) => {\n        if (isRelative) {\n          const tableWidth = totalWidth + pixelDelta;\n          const ratio = tableWidth / totalWidth;\n          const newSizes = map$1(sizes, size => size / ratio);\n          return {\n            delta: ratio * 100 - 100,\n            newSizes\n          };\n        } else {\n          return {\n            delta: pixelDelta,\n            newSizes: sizes\n          };\n        }\n      };\n      return {\n        resizeTable,\n        clampTableDelta: clampNegativeDelta,\n        calcLeftEdgeDeltas,\n        calcMiddleDeltas,\n        calcRightEdgeDeltas,\n        calcRedestributedWidths\n      };\n    };\n    const preserveTable = () => {\n      const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize) => {\n        const idx = delta >= 0 ? next : index;\n        const clampedDelta = clampDelta(sizes, idx, delta, minCellSize);\n        return surround(sizes, index, next + 1, [\n          clampedDelta,\n          -clampedDelta\n        ], zero);\n      };\n      const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize) => calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize);\n      const resizeTable = (resizer, delta, isLastColumn) => {\n        if (isLastColumn) {\n          resizer(delta);\n        }\n      };\n      const calcRightEdgeDeltas = (sizes, _prev, _index, delta, _minCellSize, isRelative) => {\n        if (isRelative) {\n          return zero(sizes);\n        } else {\n          const diff = delta / sizes.length;\n          return map$1(sizes, constant(diff));\n        }\n      };\n      const clampTableDelta = (sizes, index, delta, minCellSize, isLastColumn) => {\n        if (isLastColumn) {\n          if (delta >= 0) {\n            return delta;\n          } else {\n            const maxDelta = foldl(sizes, (a, b) => a + b - minCellSize, 0);\n            return Math.max(-maxDelta, delta);\n          }\n        } else {\n          return clampNegativeDelta(sizes, index, delta, minCellSize);\n        }\n      };\n      const calcRedestributedWidths = (sizes, _totalWidth, _pixelDelta, _isRelative) => ({\n        delta: 0,\n        newSizes: sizes\n      });\n      return {\n        resizeTable,\n        clampTableDelta,\n        calcLeftEdgeDeltas,\n        calcMiddleDeltas,\n        calcRightEdgeDeltas,\n        calcRedestributedWidths\n      };\n    };\n\n    const getGridSize = table => {\n      const warehouse = Warehouse.fromTable(table);\n      return warehouse.grid;\n    };\n\n    const isHeaderCell = isTag('th');\n    const isHeaderCells = cells => forall(cells, cell => isHeaderCell(cell.element));\n    const getRowHeaderType = (isHeaderRow, isHeaderCells) => {\n      if (isHeaderRow && isHeaderCells) {\n        return 'sectionCells';\n      } else if (isHeaderRow) {\n        return 'section';\n      } else {\n        return 'cells';\n      }\n    };\n    const getRowType = row => {\n      const isHeaderRow = row.section === 'thead';\n      const isHeaderCells = is(findCommonCellType(row.cells), 'th');\n      if (row.section === 'tfoot') {\n        return { type: 'footer' };\n      } else if (isHeaderRow || isHeaderCells) {\n        return {\n          type: 'header',\n          subType: getRowHeaderType(isHeaderRow, isHeaderCells)\n        };\n      } else {\n        return { type: 'body' };\n      }\n    };\n    const findCommonCellType = cells => {\n      const headerCells = filter$2(cells, cell => isHeaderCell(cell.element));\n      if (headerCells.length === 0) {\n        return Optional.some('td');\n      } else if (headerCells.length === cells.length) {\n        return Optional.some('th');\n      } else {\n        return Optional.none();\n      }\n    };\n    const findCommonRowType = rows => {\n      const rowTypes = map$1(rows, row => getRowType(row).type);\n      const hasHeader = contains$2(rowTypes, 'header');\n      const hasFooter = contains$2(rowTypes, 'footer');\n      if (!hasHeader && !hasFooter) {\n        return Optional.some('body');\n      } else {\n        const hasBody = contains$2(rowTypes, 'body');\n        if (hasHeader && !hasBody && !hasFooter) {\n          return Optional.some('header');\n        } else if (!hasHeader && !hasBody && hasFooter) {\n          return Optional.some('footer');\n        } else {\n          return Optional.none();\n        }\n      }\n    };\n    const findTableRowHeaderType = warehouse => findMap(warehouse.all, row => {\n      const rowType = getRowType(row);\n      return rowType.type === 'header' ? Optional.from(rowType.subType) : Optional.none();\n    });\n\n    const transformCell = (cell, comparator, substitution) => elementnew(substitution(cell.element, comparator), true, cell.isLocked);\n    const transformRow = (row, section) => row.section !== section ? rowcells(row.element, row.cells, section, row.isNew) : row;\n    const section = () => ({\n      transformRow,\n      transformCell: (cell, comparator, substitution) => {\n        const newCell = substitution(cell.element, comparator);\n        const fixedCell = name(newCell) !== 'td' ? mutate$1(newCell, 'td') : newCell;\n        return elementnew(fixedCell, cell.isNew, cell.isLocked);\n      }\n    });\n    const sectionCells = () => ({\n      transformRow,\n      transformCell\n    });\n    const cells = () => ({\n      transformRow: (row, section) => {\n        const newSection = section === 'thead' ? 'tbody' : section;\n        return transformRow(row, newSection);\n      },\n      transformCell\n    });\n    const fallback = () => ({\n      transformRow: identity,\n      transformCell\n    });\n    const getTableSectionType = (table, fallback) => {\n      const warehouse = Warehouse.fromTable(table);\n      const type = findTableRowHeaderType(warehouse).getOr(fallback);\n      switch (type) {\n      case 'section':\n        return section();\n      case 'sectionCells':\n        return sectionCells();\n      case 'cells':\n        return cells();\n      }\n    };\n    const TableSection = {\n      getTableSectionType,\n      section,\n      sectionCells,\n      cells,\n      fallback\n    };\n\n    const closest = target => closest$1(target, '[contenteditable]');\n    const isEditable$1 = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest(element).fold(constant(assumeEditable), editable => getRaw(editable) === 'true');\n      }\n    };\n    const getRaw = element => element.dom.contentEditable;\n\n    const setIfNot = (element, property, value, ignore) => {\n      if (value === ignore) {\n        remove$7(element, property);\n      } else {\n        set$2(element, property, value);\n      }\n    };\n    const insert$1 = (table, selector, element) => {\n      last$2(children(table, selector)).fold(() => prepend(table, element), child => after$5(child, element));\n    };\n    const generateSection = (table, sectionName) => {\n      const section = child(table, sectionName).getOrThunk(() => {\n        const newSection = SugarElement.fromTag(sectionName, owner(table).dom);\n        if (sectionName === 'thead') {\n          insert$1(table, 'caption,colgroup', newSection);\n        } else if (sectionName === 'colgroup') {\n          insert$1(table, 'caption', newSection);\n        } else {\n          append$1(table, newSection);\n        }\n        return newSection;\n      });\n      empty(section);\n      return section;\n    };\n    const render$1 = (table, grid) => {\n      const newRows = [];\n      const newCells = [];\n      const syncRows = gridSection => map$1(gridSection, row => {\n        if (row.isNew) {\n          newRows.push(row.element);\n        }\n        const tr = row.element;\n        empty(tr);\n        each$2(row.cells, cell => {\n          if (cell.isNew) {\n            newCells.push(cell.element);\n          }\n          setIfNot(cell.element, 'colspan', cell.colspan, 1);\n          setIfNot(cell.element, 'rowspan', cell.rowspan, 1);\n          append$1(tr, cell.element);\n        });\n        return tr;\n      });\n      const syncColGroup = gridSection => bind$2(gridSection, colGroup => map$1(colGroup.cells, col => {\n        setIfNot(col.element, 'span', col.colspan, 1);\n        return col.element;\n      }));\n      const renderSection = (gridSection, sectionName) => {\n        const section = generateSection(table, sectionName);\n        const sync = sectionName === 'colgroup' ? syncColGroup : syncRows;\n        const sectionElems = sync(gridSection);\n        append(section, sectionElems);\n      };\n      const removeSection = sectionName => {\n        child(table, sectionName).each(remove$6);\n      };\n      const renderOrRemoveSection = (gridSection, sectionName) => {\n        if (gridSection.length > 0) {\n          renderSection(gridSection, sectionName);\n        } else {\n          removeSection(sectionName);\n        }\n      };\n      const headSection = [];\n      const bodySection = [];\n      const footSection = [];\n      const columnGroupsSection = [];\n      each$2(grid, row => {\n        switch (row.section) {\n        case 'thead':\n          headSection.push(row);\n          break;\n        case 'tbody':\n          bodySection.push(row);\n          break;\n        case 'tfoot':\n          footSection.push(row);\n          break;\n        case 'colgroup':\n          columnGroupsSection.push(row);\n          break;\n        }\n      });\n      renderOrRemoveSection(columnGroupsSection, 'colgroup');\n      renderOrRemoveSection(headSection, 'thead');\n      renderOrRemoveSection(bodySection, 'tbody');\n      renderOrRemoveSection(footSection, 'tfoot');\n      return {\n        newRows,\n        newCells\n      };\n    };\n    const copy = grid => map$1(grid, row => {\n      const tr = shallow(row.element);\n      each$2(row.cells, cell => {\n        const clonedCell = deep(cell.element);\n        setIfNot(clonedCell, 'colspan', cell.colspan, 1);\n        setIfNot(clonedCell, 'rowspan', cell.rowspan, 1);\n        append$1(tr, clonedCell);\n      });\n      return tr;\n    });\n\n    const getColumn = (grid, index) => {\n      return map$1(grid, row => {\n        return getCell(row, index);\n      });\n    };\n    const getRow = (grid, index) => {\n      return grid[index];\n    };\n    const findDiff = (xs, comp) => {\n      if (xs.length === 0) {\n        return 0;\n      }\n      const first = xs[0];\n      const index = findIndex(xs, x => {\n        return !comp(first.element, x.element);\n      });\n      return index.getOr(xs.length);\n    };\n    const subgrid = (grid, row, column, comparator) => {\n      const gridRow = getRow(grid, row);\n      const isColRow = gridRow.section === 'colgroup';\n      const colspan = findDiff(gridRow.cells.slice(column), comparator);\n      const rowspan = isColRow ? 1 : findDiff(getColumn(grid.slice(row), column), comparator);\n      return {\n        colspan,\n        rowspan\n      };\n    };\n\n    const toDetails = (grid, comparator) => {\n      const seen = map$1(grid, row => map$1(row.cells, never));\n      const updateSeen = (rowIndex, columnIndex, rowspan, colspan) => {\n        for (let row = rowIndex; row < rowIndex + rowspan; row++) {\n          for (let column = columnIndex; column < columnIndex + colspan; column++) {\n            seen[row][column] = true;\n          }\n        }\n      };\n      return map$1(grid, (row, rowIndex) => {\n        const details = bind$2(row.cells, (cell, columnIndex) => {\n          if (seen[rowIndex][columnIndex] === false) {\n            const result = subgrid(grid, rowIndex, columnIndex, comparator);\n            updateSeen(rowIndex, columnIndex, result.rowspan, result.colspan);\n            return [detailnew(cell.element, result.rowspan, result.colspan, cell.isNew)];\n          } else {\n            return [];\n          }\n        });\n        return rowdetailnew(row.element, details, row.section, row.isNew);\n      });\n    };\n    const toGrid = (warehouse, generators, isNew) => {\n      const grid = [];\n      each$2(warehouse.colgroups, colgroup => {\n        const colgroupCols = [];\n        for (let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {\n          const element = Warehouse.getColumnAt(warehouse, columnIndex).map(column => elementnew(column.element, isNew, false)).getOrThunk(() => elementnew(generators.colGap(), true, false));\n          colgroupCols.push(element);\n        }\n        grid.push(rowcells(colgroup.element, colgroupCols, 'colgroup', isNew));\n      });\n      for (let rowIndex = 0; rowIndex < warehouse.grid.rows; rowIndex++) {\n        const rowCells = [];\n        for (let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {\n          const element = Warehouse.getAt(warehouse, rowIndex, columnIndex).map(item => elementnew(item.element, isNew, item.isLocked)).getOrThunk(() => elementnew(generators.gap(), true, false));\n          rowCells.push(element);\n        }\n        const rowDetail = warehouse.all[rowIndex];\n        const row = rowcells(rowDetail.element, rowCells, rowDetail.section, isNew);\n        grid.push(row);\n      }\n      return grid;\n    };\n\n    const fromWarehouse = (warehouse, generators) => toGrid(warehouse, generators, false);\n    const toDetailList = grid => toDetails(grid, eq$1);\n    const findInWarehouse = (warehouse, element) => findMap(warehouse.all, r => find$1(r.cells, e => eq$1(element, e.element)));\n    const extractCells = (warehouse, target, predicate) => {\n      const details = map$1(target.selection, cell$1 => {\n        return cell(cell$1).bind(lc => findInWarehouse(warehouse, lc)).filter(predicate);\n      });\n      const cells = cat(details);\n      return someIf(cells.length > 0, cells);\n    };\n    const run = (operation, extract, adjustment, postAction, genWrappers) => (table, target, generators, behaviours) => {\n      const warehouse = Warehouse.fromTable(table);\n      const tableSection = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.section).getOrThunk(TableSection.fallback);\n      const output = extract(warehouse, target).map(info => {\n        const model = fromWarehouse(warehouse, generators);\n        const result = operation(model, info, eq$1, genWrappers(generators), tableSection);\n        const lockedColumns = getLockedColumnsFromGrid(result.grid);\n        const grid = toDetailList(result.grid);\n        return {\n          info,\n          grid,\n          cursor: result.cursor,\n          lockedColumns\n        };\n      });\n      return output.bind(out => {\n        const newElements = render$1(table, out.grid);\n        const tableSizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.sizing).getOrThunk(() => TableSize.getTableSize(table));\n        const resizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.resize).getOrThunk(preserveTable);\n        adjustment(table, out.grid, out.info, {\n          sizing: tableSizing,\n          resize: resizing,\n          section: tableSection\n        });\n        postAction(table);\n        remove$7(table, LOCKED_COL_ATTR);\n        if (out.lockedColumns.length > 0) {\n          set$2(table, LOCKED_COL_ATTR, out.lockedColumns.join(','));\n        }\n        return Optional.some({\n          cursor: out.cursor,\n          newRows: newElements.newRows,\n          newCells: newElements.newCells\n        });\n      });\n    };\n    const onPaste = (warehouse, target) => cell(target.element).bind(cell => findInWarehouse(warehouse, cell).map(details => {\n      const value = {\n        ...details,\n        generators: target.generators,\n        clipboard: target.clipboard\n      };\n      return value;\n    }));\n    const onPasteByEditor = (warehouse, target) => extractCells(warehouse, target, always).map(cells => ({\n      cells,\n      generators: target.generators,\n      clipboard: target.clipboard\n    }));\n    const onMergable = (_warehouse, target) => target.mergable;\n    const onUnmergable = (_warehouse, target) => target.unmergable;\n    const onCells = (warehouse, target) => extractCells(warehouse, target, always);\n    const onUnlockedCells = (warehouse, target) => extractCells(warehouse, target, detail => !detail.isLocked);\n    const isUnlockedTableCell = (warehouse, cell) => findInWarehouse(warehouse, cell).exists(detail => !detail.isLocked);\n    const allUnlocked = (warehouse, cells) => forall(cells, cell => isUnlockedTableCell(warehouse, cell));\n    const onUnlockedMergable = (warehouse, target) => onMergable(warehouse, target).filter(mergeable => allUnlocked(warehouse, mergeable.cells));\n    const onUnlockedUnmergable = (warehouse, target) => onUnmergable(warehouse, target).filter(cells => allUnlocked(warehouse, cells));\n\n    const merge$2 = (grid, bounds, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      if (rows.length === 0) {\n        return grid;\n      }\n      for (let i = bounds.startRow; i <= bounds.finishRow; i++) {\n        for (let j = bounds.startCol; j <= bounds.finishCol; j++) {\n          const row = rows[i];\n          const isLocked = getCell(row, j).isLocked;\n          mutateCell(row, j, elementnew(substitution(), false, isLocked));\n        }\n      }\n      return grid;\n    };\n    const unmerge = (grid, target, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      let first = true;\n      for (let i = 0; i < rows.length; i++) {\n        for (let j = 0; j < cellLength(rows[0]); j++) {\n          const row = rows[i];\n          const currentCell = getCell(row, j);\n          const currentCellElm = currentCell.element;\n          const isToReplace = comparator(currentCellElm, target);\n          if (isToReplace && !first) {\n            mutateCell(row, j, elementnew(substitution(), true, currentCell.isLocked));\n          } else if (isToReplace) {\n            first = false;\n          }\n        }\n      }\n      return grid;\n    };\n    const uniqueCells = (row, comparator) => {\n      return foldl(row, (rest, cell) => {\n        return exists(rest, currentCell => {\n          return comparator(currentCell.element, cell.element);\n        }) ? rest : rest.concat([cell]);\n      }, []);\n    };\n    const splitCols = (grid, index, comparator, substitution) => {\n      if (index > 0 && index < grid[0].cells.length) {\n        each$2(grid, row => {\n          const prevCell = row.cells[index - 1];\n          let offset = 0;\n          const substitute = substitution();\n          while (row.cells.length > index + offset && comparator(prevCell.element, row.cells[index + offset].element)) {\n            mutateCell(row, index + offset, elementnew(substitute, true, row.cells[index + offset].isLocked));\n            offset++;\n          }\n        });\n      }\n      return grid;\n    };\n    const splitRows = (grid, index, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      if (index > 0 && index < rows.length) {\n        const rowPrevCells = rows[index - 1].cells;\n        const cells = uniqueCells(rowPrevCells, comparator);\n        each$2(cells, cell => {\n          let replacement = Optional.none();\n          for (let i = index; i < rows.length; i++) {\n            for (let j = 0; j < cellLength(rows[0]); j++) {\n              const row = rows[i];\n              const current = getCell(row, j);\n              const isToReplace = comparator(current.element, cell.element);\n              if (isToReplace) {\n                if (replacement.isNone()) {\n                  replacement = Optional.some(substitution());\n                }\n                replacement.each(sub => {\n                  mutateCell(row, j, elementnew(sub, true, current.isLocked));\n                });\n              }\n            }\n          }\n        });\n      }\n      return grid;\n    };\n\n    const value$1 = value => {\n      const applyHelper = fn => fn(value);\n      const constHelper = constant(value);\n      const outputHelper = () => output;\n      const output = {\n        tag: true,\n        inner: value,\n        fold: (_onError, onValue) => onValue(value),\n        isValue: always,\n        isError: never,\n        map: mapper => Result.value(mapper(value)),\n        mapError: outputHelper,\n        bind: applyHelper,\n        exists: applyHelper,\n        forall: applyHelper,\n        getOr: constHelper,\n        or: outputHelper,\n        getOrThunk: constHelper,\n        orThunk: outputHelper,\n        getOrDie: constHelper,\n        each: fn => {\n          fn(value);\n        },\n        toOptional: () => Optional.some(value)\n      };\n      return output;\n    };\n    const error = error => {\n      const outputHelper = () => output;\n      const output = {\n        tag: false,\n        inner: error,\n        fold: (onError, _onValue) => onError(error),\n        isValue: never,\n        isError: always,\n        map: outputHelper,\n        mapError: mapper => Result.error(mapper(error)),\n        bind: outputHelper,\n        exists: never,\n        forall: always,\n        getOr: identity,\n        or: identity,\n        getOrThunk: apply,\n        orThunk: apply,\n        getOrDie: die(String(error)),\n        each: noop,\n        toOptional: Optional.none\n      };\n      return output;\n    };\n    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n    const Result = {\n      value: value$1,\n      error,\n      fromOption\n    };\n\n    const measure = (startAddress, gridA, gridB) => {\n      if (startAddress.row >= gridA.length || startAddress.column > cellLength(gridA[0])) {\n        return Result.error('invalid start address out of table bounds, row: ' + startAddress.row + ', column: ' + startAddress.column);\n      }\n      const rowRemainder = gridA.slice(startAddress.row);\n      const colRemainder = rowRemainder[0].cells.slice(startAddress.column);\n      const colRequired = cellLength(gridB[0]);\n      const rowRequired = gridB.length;\n      return Result.value({\n        rowDelta: rowRemainder.length - rowRequired,\n        colDelta: colRemainder.length - colRequired\n      });\n    };\n    const measureWidth = (gridA, gridB) => {\n      const colLengthA = cellLength(gridA[0]);\n      const colLengthB = cellLength(gridB[0]);\n      return {\n        rowDelta: 0,\n        colDelta: colLengthA - colLengthB\n      };\n    };\n    const measureHeight = (gridA, gridB) => {\n      const rowLengthA = gridA.length;\n      const rowLengthB = gridB.length;\n      return {\n        rowDelta: rowLengthA - rowLengthB,\n        colDelta: 0\n      };\n    };\n    const generateElements = (amount, row, generators, isLocked) => {\n      const generator = row.section === 'colgroup' ? generators.col : generators.cell;\n      return range$1(amount, idx => elementnew(generator(), true, isLocked(idx)));\n    };\n    const rowFill = (grid, amount, generators, lockedColumns) => {\n      const exampleRow = grid[grid.length - 1];\n      return grid.concat(range$1(amount, () => {\n        const generator = exampleRow.section === 'colgroup' ? generators.colgroup : generators.row;\n        const row = clone(exampleRow, generator, identity);\n        const elements = generateElements(row.cells.length, row, generators, idx => has$1(lockedColumns, idx.toString()));\n        return setCells(row, elements);\n      }));\n    };\n    const colFill = (grid, amount, generators, startIndex) => map$1(grid, row => {\n      const newChildren = generateElements(amount, row, generators, never);\n      return addCells(row, startIndex, newChildren);\n    });\n    const lockedColFill = (grid, generators, lockedColumns) => map$1(grid, row => {\n      return foldl(lockedColumns, (acc, colNum) => {\n        const newChild = generateElements(1, row, generators, always)[0];\n        return addCell(acc, colNum, newChild);\n      }, row);\n    });\n    const tailor = (gridA, delta, generators) => {\n      const fillCols = delta.colDelta < 0 ? colFill : identity;\n      const fillRows = delta.rowDelta < 0 ? rowFill : identity;\n      const lockedColumns = getLockedColumnsFromGrid(gridA);\n      const gridWidth = cellLength(gridA[0]);\n      const isLastColLocked = exists(lockedColumns, locked => locked === gridWidth - 1);\n      const modifiedCols = fillCols(gridA, Math.abs(delta.colDelta), generators, isLastColLocked ? gridWidth - 1 : gridWidth);\n      const newLockedColumns = getLockedColumnsFromGrid(modifiedCols);\n      return fillRows(modifiedCols, Math.abs(delta.rowDelta), generators, mapToObject(newLockedColumns, always));\n    };\n\n    const isSpanning = (grid, row, col, comparator) => {\n      const candidate = getCell(grid[row], col);\n      const matching = curry(comparator, candidate.element);\n      const currentRow = grid[row];\n      return grid.length > 1 && cellLength(currentRow) > 1 && (col > 0 && matching(getCellElement(currentRow, col - 1)) || col < currentRow.cells.length - 1 && matching(getCellElement(currentRow, col + 1)) || row > 0 && matching(getCellElement(grid[row - 1], col)) || row < grid.length - 1 && matching(getCellElement(grid[row + 1], col)));\n    };\n    const mergeTables = (startAddress, gridA, gridBRows, generator, comparator, lockedColumns) => {\n      const startRow = startAddress.row;\n      const startCol = startAddress.column;\n      const mergeHeight = gridBRows.length;\n      const mergeWidth = cellLength(gridBRows[0]);\n      const endRow = startRow + mergeHeight;\n      const endCol = startCol + mergeWidth + lockedColumns.length;\n      const lockedColumnObj = mapToObject(lockedColumns, always);\n      for (let r = startRow; r < endRow; r++) {\n        let skippedCol = 0;\n        for (let c = startCol; c < endCol; c++) {\n          if (lockedColumnObj[c]) {\n            skippedCol++;\n            continue;\n          }\n          if (isSpanning(gridA, r, c, comparator)) {\n            unmerge(gridA, getCellElement(gridA[r], c), comparator, generator.cell);\n          }\n          const gridBColIndex = c - startCol - skippedCol;\n          const newCell = getCell(gridBRows[r - startRow], gridBColIndex);\n          const newCellElm = newCell.element;\n          const replacement = generator.replace(newCellElm);\n          mutateCell(gridA[r], c, elementnew(replacement, true, newCell.isLocked));\n        }\n      }\n      return gridA;\n    };\n    const getValidStartAddress = (currentStartAddress, grid, lockedColumns) => {\n      const gridColLength = cellLength(grid[0]);\n      const adjustedRowAddress = extractGridDetails(grid).cols.length + currentStartAddress.row;\n      const possibleColAddresses = range$1(gridColLength - currentStartAddress.column, num => num + currentStartAddress.column);\n      const validColAddress = find$1(possibleColAddresses, num => forall(lockedColumns, col => col !== num)).getOr(gridColLength - 1);\n      return {\n        row: adjustedRowAddress,\n        column: validColAddress\n      };\n    };\n    const getLockedColumnsWithinBounds = (startAddress, rows, lockedColumns) => filter$2(lockedColumns, colNum => colNum >= startAddress.column && colNum <= cellLength(rows[0]) + startAddress.column);\n    const merge$1 = (startAddress, gridA, gridB, generator, comparator) => {\n      const lockedColumns = getLockedColumnsFromGrid(gridA);\n      const validStartAddress = getValidStartAddress(startAddress, gridA, lockedColumns);\n      const gridBRows = extractGridDetails(gridB).rows;\n      const lockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, lockedColumns);\n      const result = measure(validStartAddress, gridA, gridBRows);\n      return result.map(diff => {\n        const delta = {\n          ...diff,\n          colDelta: diff.colDelta - lockedColumnsWithinBounds.length\n        };\n        const fittedGrid = tailor(gridA, delta, generator);\n        const newLockedColumns = getLockedColumnsFromGrid(fittedGrid);\n        const newLockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, newLockedColumns);\n        return mergeTables(validStartAddress, fittedGrid, gridBRows, generator, comparator, newLockedColumnsWithinBounds);\n      });\n    };\n    const insertCols = (index, gridA, gridB, generator, comparator) => {\n      splitCols(gridA, index, comparator, generator.cell);\n      const delta = measureHeight(gridB, gridA);\n      const fittedNewGrid = tailor(gridB, delta, generator);\n      const secondDelta = measureHeight(gridA, fittedNewGrid);\n      const fittedOldGrid = tailor(gridA, secondDelta, generator);\n      return map$1(fittedOldGrid, (gridRow, i) => {\n        return addCells(gridRow, index, fittedNewGrid[i].cells);\n      });\n    };\n    const insertRows = (index, gridA, gridB, generator, comparator) => {\n      splitRows(gridA, index, comparator, generator.cell);\n      const locked = getLockedColumnsFromGrid(gridA);\n      const diff = measureWidth(gridA, gridB);\n      const delta = {\n        ...diff,\n        colDelta: diff.colDelta - locked.length\n      };\n      const fittedOldGrid = tailor(gridA, delta, generator);\n      const {\n        cols: oldCols,\n        rows: oldRows\n      } = extractGridDetails(fittedOldGrid);\n      const newLocked = getLockedColumnsFromGrid(fittedOldGrid);\n      const secondDiff = measureWidth(gridB, gridA);\n      const secondDelta = {\n        ...secondDiff,\n        colDelta: secondDiff.colDelta + newLocked.length\n      };\n      const fittedGridB = lockedColFill(gridB, generator, newLocked);\n      const fittedNewGrid = tailor(fittedGridB, secondDelta, generator);\n      return [\n        ...oldCols,\n        ...oldRows.slice(0, index),\n        ...fittedNewGrid,\n        ...oldRows.slice(index, oldRows.length)\n      ];\n    };\n\n    const cloneRow = (row, cloneCell, comparator, substitution) => clone(row, elem => substitution(elem, comparator), cloneCell);\n    const insertRowAt = (grid, index, example, comparator, substitution) => {\n      const {rows, cols} = extractGridDetails(grid);\n      const before = rows.slice(0, index);\n      const after = rows.slice(index);\n      const newRow = cloneRow(rows[example], (ex, c) => {\n        const withinSpan = index > 0 && index < rows.length && comparator(getCellElement(rows[index - 1], c), getCellElement(rows[index], c));\n        const ret = withinSpan ? getCell(rows[index], c) : elementnew(substitution(ex.element, comparator), true, ex.isLocked);\n        return ret;\n      }, comparator, substitution);\n      return [\n        ...cols,\n        ...before,\n        newRow,\n        ...after\n      ];\n    };\n    const getElementFor = (row, column, section, withinSpan, example, comparator, substitution) => {\n      if (section === 'colgroup' || !withinSpan) {\n        const cell = getCell(row, example);\n        return elementnew(substitution(cell.element, comparator), true, false);\n      } else {\n        return getCell(row, column);\n      }\n    };\n    const insertColumnAt = (grid, index, example, comparator, substitution) => map$1(grid, row => {\n      const withinSpan = index > 0 && index < cellLength(row) && comparator(getCellElement(row, index - 1), getCellElement(row, index));\n      const sub = getElementFor(row, index, row.section, withinSpan, example, comparator, substitution);\n      return addCell(row, index, sub);\n    });\n    const deleteColumnsAt = (grid, columns) => bind$2(grid, row => {\n      const existingCells = row.cells;\n      const cells = foldr(columns, (acc, column) => column >= 0 && column < acc.length ? acc.slice(0, column).concat(acc.slice(column + 1)) : acc, existingCells);\n      return cells.length > 0 ? [rowcells(row.element, cells, row.section, row.isNew)] : [];\n    });\n    const deleteRowsAt = (grid, start, finish) => {\n      const {rows, cols} = extractGridDetails(grid);\n      return [\n        ...cols,\n        ...rows.slice(0, start),\n        ...rows.slice(finish + 1)\n      ];\n    };\n\n    const notInStartRow = (grid, rowIndex, colIndex, comparator) => getCellElement(grid[rowIndex], colIndex) !== undefined && (rowIndex > 0 && comparator(getCellElement(grid[rowIndex - 1], colIndex), getCellElement(grid[rowIndex], colIndex)));\n    const notInStartColumn = (row, index, comparator) => index > 0 && comparator(getCellElement(row, index - 1), getCellElement(row, index));\n    const isDuplicatedCell = (grid, rowIndex, colIndex, comparator) => notInStartRow(grid, rowIndex, colIndex, comparator) || notInStartColumn(grid[rowIndex], colIndex, comparator);\n    const rowReplacerPredicate = (targetRow, columnHeaders) => {\n      const entireTableIsHeader = forall(columnHeaders, identity) && isHeaderCells(targetRow.cells);\n      return entireTableIsHeader ? always : (cell, _rowIndex, colIndex) => {\n        const type = name(cell.element);\n        return !(type === 'th' && columnHeaders[colIndex]);\n      };\n    };\n    const columnReplacePredicate = (targetColumn, rowHeaders) => {\n      const entireTableIsHeader = forall(rowHeaders, identity) && isHeaderCells(targetColumn);\n      return entireTableIsHeader ? always : (cell, rowIndex, _colIndex) => {\n        const type = name(cell.element);\n        return !(type === 'th' && rowHeaders[rowIndex]);\n      };\n    };\n    const determineScope = (applyScope, cell, newScope, isInHeader) => {\n      const hasSpan = scope => scope === 'row' ? hasRowspan(cell) : hasColspan(cell);\n      const getScope = scope => hasSpan(scope) ? `${ scope }group` : scope;\n      if (applyScope) {\n        return isHeaderCell(cell) ? getScope(newScope) : null;\n      } else if (isInHeader && isHeaderCell(cell)) {\n        const oppositeScope = newScope === 'row' ? 'col' : 'row';\n        return getScope(oppositeScope);\n      } else {\n        return null;\n      }\n    };\n    const rowScopeGenerator = (applyScope, columnHeaders) => (cell, rowIndex, columnIndex) => Optional.some(determineScope(applyScope, cell.element, 'col', columnHeaders[columnIndex]));\n    const columnScopeGenerator = (applyScope, rowHeaders) => (cell, rowIndex) => Optional.some(determineScope(applyScope, cell.element, 'row', rowHeaders[rowIndex]));\n    const replace = (cell, comparator, substitute) => elementnew(substitute(cell.element, comparator), true, cell.isLocked);\n    const replaceIn = (grid, targets, comparator, substitute, replacer, genScope, shouldReplace) => {\n      const isTarget = cell => {\n        return exists(targets, target => {\n          return comparator(cell.element, target.element);\n        });\n      };\n      return map$1(grid, (row, rowIndex) => {\n        return mapCells(row, (cell, colIndex) => {\n          if (isTarget(cell)) {\n            const newCell = shouldReplace(cell, rowIndex, colIndex) ? replacer(cell, comparator, substitute) : cell;\n            genScope(newCell, rowIndex, colIndex).each(scope => {\n              setOptions(newCell.element, { scope: Optional.from(scope) });\n            });\n            return newCell;\n          } else {\n            return cell;\n          }\n        });\n      });\n    };\n    const getColumnCells = (rows, columnIndex, comparator) => bind$2(rows, (row, i) => {\n      return isDuplicatedCell(rows, i, columnIndex, comparator) ? [] : [getCell(row, columnIndex)];\n    });\n    const getRowCells = (rows, rowIndex, comparator) => {\n      const targetRow = rows[rowIndex];\n      return bind$2(targetRow.cells, (item, i) => {\n        return isDuplicatedCell(rows, rowIndex, i, comparator) ? [] : [item];\n      });\n    };\n    const replaceColumns = (grid, indexes, applyScope, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      const targets = bind$2(indexes, index => getColumnCells(rows, index, comparator));\n      const rowHeaders = map$1(rows, row => isHeaderCells(row.cells));\n      const shouldReplaceCell = columnReplacePredicate(targets, rowHeaders);\n      const scopeGenerator = columnScopeGenerator(applyScope, rowHeaders);\n      return replaceIn(grid, targets, comparator, substitution, replace, scopeGenerator, shouldReplaceCell);\n    };\n    const replaceRows = (grid, indexes, section, applyScope, comparator, substitution, tableSection) => {\n      const {cols, rows} = extractGridDetails(grid);\n      const targetRow = rows[indexes[0]];\n      const targets = bind$2(indexes, index => getRowCells(rows, index, comparator));\n      const columnHeaders = map$1(targetRow.cells, (_cell, index) => isHeaderCells(getColumnCells(rows, index, comparator)));\n      const newRows = [...rows];\n      each$2(indexes, index => {\n        newRows[index] = tableSection.transformRow(rows[index], section);\n      });\n      const newGrid = [\n        ...cols,\n        ...newRows\n      ];\n      const shouldReplaceCell = rowReplacerPredicate(targetRow, columnHeaders);\n      const scopeGenerator = rowScopeGenerator(applyScope, columnHeaders);\n      return replaceIn(newGrid, targets, comparator, substitution, tableSection.transformCell, scopeGenerator, shouldReplaceCell);\n    };\n    const replaceCells = (grid, details, comparator, substitution) => {\n      const rows = extractGridDetails(grid).rows;\n      const targetCells = map$1(details, detail => getCell(rows[detail.row], detail.column));\n      return replaceIn(grid, targetCells, comparator, substitution, replace, Optional.none, always);\n    };\n\n    const generate = cases => {\n      if (!isArray(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      const constructors = [];\n      const adt = {};\n      each$2(cases, (acase, count) => {\n        const keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        const key = keys$1[0];\n        const value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = (...args) => {\n          const argLength = args.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          const match = branches => {\n            const branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            const allReqd = forall(constructors, reqKey => {\n              return contains$2(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: (...foldArgs) => {\n              if (foldArgs.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n              }\n              const target = foldArgs[count];\n              return target.apply(null, args);\n            },\n            match,\n            log: label => {\n              console.log(label, {\n                constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    const Adt = { generate };\n\n    const adt$6 = Adt.generate([\n      { none: [] },\n      { only: ['index'] },\n      {\n        left: [\n          'index',\n          'next'\n        ]\n      },\n      {\n        middle: [\n          'prev',\n          'index',\n          'next'\n        ]\n      },\n      {\n        right: [\n          'prev',\n          'index'\n        ]\n      }\n    ]);\n    const ColumnContext = { ...adt$6 };\n\n    const neighbours = (input, index) => {\n      if (input.length === 0) {\n        return ColumnContext.none();\n      }\n      if (input.length === 1) {\n        return ColumnContext.only(0);\n      }\n      if (index === 0) {\n        return ColumnContext.left(0, 1);\n      }\n      if (index === input.length - 1) {\n        return ColumnContext.right(index - 1, index);\n      }\n      if (index > 0 && index < input.length - 1) {\n        return ColumnContext.middle(index - 1, index, index + 1);\n      }\n      return ColumnContext.none();\n    };\n    const determine = (input, column, step, tableSize, resize) => {\n      const result = input.slice(0);\n      const context = neighbours(input, column);\n      const onNone = constant(map$1(result, constant(0)));\n      const onOnly = index => tableSize.singleColumnWidth(result[index], step);\n      const onLeft = (index, next) => resize.calcLeftEdgeDeltas(result, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);\n      const onMiddle = (prev, index, next) => resize.calcMiddleDeltas(result, prev, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);\n      const onRight = (prev, index) => resize.calcRightEdgeDeltas(result, prev, index, step, tableSize.minCellWidth(), tableSize.isRelative);\n      return context.fold(onNone, onOnly, onLeft, onMiddle, onRight);\n    };\n\n    const total = (start, end, measures) => {\n      let r = 0;\n      for (let i = start; i < end; i++) {\n        r += measures[i] !== undefined ? measures[i] : 0;\n      }\n      return r;\n    };\n    const recalculateWidthForCells = (warehouse, widths) => {\n      const all = Warehouse.justCells(warehouse);\n      return map$1(all, cell => {\n        const width = total(cell.column, cell.column + cell.colspan, widths);\n        return {\n          element: cell.element,\n          width,\n          colspan: cell.colspan\n        };\n      });\n    };\n    const recalculateWidthForColumns = (warehouse, widths) => {\n      const groups = Warehouse.justColumns(warehouse);\n      return map$1(groups, (column, index) => ({\n        element: column.element,\n        width: widths[index],\n        colspan: column.colspan\n      }));\n    };\n    const recalculateHeightForCells = (warehouse, heights) => {\n      const all = Warehouse.justCells(warehouse);\n      return map$1(all, cell => {\n        const height = total(cell.row, cell.row + cell.rowspan, heights);\n        return {\n          element: cell.element,\n          height,\n          rowspan: cell.rowspan\n        };\n      });\n    };\n    const matchRowHeight = (warehouse, heights) => {\n      return map$1(warehouse.all, (row, i) => {\n        return {\n          element: row.element,\n          height: heights[i]\n        };\n      });\n    };\n\n    const sumUp = newSize => foldr(newSize, (b, a) => b + a, 0);\n    const recalculate = (warehouse, widths) => {\n      if (Warehouse.hasColumns(warehouse)) {\n        return recalculateWidthForColumns(warehouse, widths);\n      } else {\n        return recalculateWidthForCells(warehouse, widths);\n      }\n    };\n    const recalculateAndApply = (warehouse, widths, tableSize) => {\n      const newSizes = recalculate(warehouse, widths);\n      each$2(newSizes, cell => {\n        tableSize.setElementWidth(cell.element, cell.width);\n      });\n    };\n    const adjustWidth = (table, delta, index, resizing, tableSize) => {\n      const warehouse = Warehouse.fromTable(table);\n      const step = tableSize.getCellDelta(delta);\n      const widths = tableSize.getWidths(warehouse, tableSize);\n      const isLastColumn = index === warehouse.grid.columns - 1;\n      const clampedStep = resizing.clampTableDelta(widths, index, step, tableSize.minCellWidth(), isLastColumn);\n      const deltas = determine(widths, index, clampedStep, tableSize, resizing);\n      const newWidths = map$1(deltas, (dx, i) => dx + widths[i]);\n      recalculateAndApply(warehouse, newWidths, tableSize);\n      resizing.resizeTable(tableSize.adjustTableWidth, clampedStep, isLastColumn);\n    };\n    const adjustHeight = (table, delta, index, direction) => {\n      const warehouse = Warehouse.fromTable(table);\n      const heights = getPixelHeights(warehouse, table, direction);\n      const newHeights = map$1(heights, (dy, i) => index === i ? Math.max(delta + dy, minHeight()) : dy);\n      const newCellSizes = recalculateHeightForCells(warehouse, newHeights);\n      const newRowSizes = matchRowHeight(warehouse, newHeights);\n      each$2(newRowSizes, row => {\n        setHeight(row.element, row.height);\n      });\n      each$2(newCellSizes, cell => {\n        setHeight(cell.element, cell.height);\n      });\n      const total = sumUp(newHeights);\n      setHeight(table, total);\n    };\n    const adjustAndRedistributeWidths$1 = (_table, list, details, tableSize, resizeBehaviour) => {\n      const warehouse = Warehouse.generate(list);\n      const sizes = tableSize.getWidths(warehouse, tableSize);\n      const tablePixelWidth = tableSize.pixelWidth();\n      const {newSizes, delta} = resizeBehaviour.calcRedestributedWidths(sizes, tablePixelWidth, details.pixelDelta, tableSize.isRelative);\n      recalculateAndApply(warehouse, newSizes, tableSize);\n      tableSize.adjustTableWidth(delta);\n    };\n    const adjustWidthTo = (_table, list, _info, tableSize) => {\n      const warehouse = Warehouse.generate(list);\n      const widths = tableSize.getWidths(warehouse, tableSize);\n      recalculateAndApply(warehouse, widths, tableSize);\n    };\n\n    const uniqueColumns = details => {\n      const uniqueCheck = (rest, detail) => {\n        const columnExists = exists(rest, currentDetail => currentDetail.column === detail.column);\n        return columnExists ? rest : rest.concat([detail]);\n      };\n      return foldl(details, uniqueCheck, []).sort((detailA, detailB) => detailA.column - detailB.column);\n    };\n\n    const isCol = isTag('col');\n    const isColgroup = isTag('colgroup');\n    const isRow$1 = element => name(element) === 'tr' || isColgroup(element);\n    const elementToData = element => {\n      const colspan = getAttrValue(element, 'colspan', 1);\n      const rowspan = getAttrValue(element, 'rowspan', 1);\n      return {\n        element,\n        colspan,\n        rowspan\n      };\n    };\n    const modification = (generators, toData = elementToData) => {\n      const nuCell = data => isCol(data.element) ? generators.col(data) : generators.cell(data);\n      const nuRow = data => isColgroup(data.element) ? generators.colgroup(data) : generators.row(data);\n      const add = element => {\n        if (isRow$1(element)) {\n          return nuRow({ element });\n        } else {\n          const cell = element;\n          const replacement = nuCell(toData(cell));\n          recent = Optional.some({\n            item: cell,\n            replacement\n          });\n          return replacement;\n        }\n      };\n      let recent = Optional.none();\n      const getOrInit = (element, comparator) => {\n        return recent.fold(() => {\n          return add(element);\n        }, p => {\n          return comparator(element, p.item) ? p.replacement : add(element);\n        });\n      };\n      return { getOrInit };\n    };\n    const transform$1 = tag => {\n      return generators => {\n        const list = [];\n        const find = (element, comparator) => {\n          return find$1(list, x => {\n            return comparator(x.item, element);\n          });\n        };\n        const makeNew = element => {\n          const attrs = tag === 'td' ? { scope: null } : {};\n          const cell = generators.replace(element, tag, attrs);\n          list.push({\n            item: element,\n            sub: cell\n          });\n          return cell;\n        };\n        const replaceOrInit = (element, comparator) => {\n          if (isRow$1(element) || isCol(element)) {\n            return element;\n          } else {\n            const cell = element;\n            return find(cell, comparator).fold(() => {\n              return makeNew(cell);\n            }, p => {\n              return comparator(element, p.item) ? p.sub : makeNew(cell);\n            });\n          }\n        };\n        return { replaceOrInit };\n      };\n    };\n    const getScopeAttribute = cell => getOpt(cell, 'scope').map(attribute => attribute.substr(0, 3));\n    const merging = generators => {\n      const unmerge = cell => {\n        const scope = getScopeAttribute(cell);\n        scope.each(attribute => set$2(cell, 'scope', attribute));\n        return () => {\n          const raw = generators.cell({\n            element: cell,\n            colspan: 1,\n            rowspan: 1\n          });\n          remove$5(raw, 'width');\n          remove$5(cell, 'width');\n          scope.each(attribute => set$2(raw, 'scope', attribute));\n          return raw;\n        };\n      };\n      const merge = cells => {\n        const getScopeProperty = () => {\n          const stringAttributes = cat(map$1(cells, getScopeAttribute));\n          if (stringAttributes.length === 0) {\n            return Optional.none();\n          } else {\n            const baseScope = stringAttributes[0];\n            const scopes = [\n              'row',\n              'col'\n            ];\n            const isMixed = exists(stringAttributes, attribute => {\n              return attribute !== baseScope && contains$2(scopes, attribute);\n            });\n            return isMixed ? Optional.none() : Optional.from(baseScope);\n          }\n        };\n        remove$5(cells[0], 'width');\n        getScopeProperty().fold(() => remove$7(cells[0], 'scope'), attribute => set$2(cells[0], 'scope', attribute + 'group'));\n        return constant(cells[0]);\n      };\n      return {\n        unmerge,\n        merge\n      };\n    };\n    const Generators = {\n      modification,\n      transform: transform$1,\n      merging\n    };\n\n    const blockList = [\n      'body',\n      'p',\n      'div',\n      'article',\n      'aside',\n      'figcaption',\n      'figure',\n      'footer',\n      'header',\n      'nav',\n      'section',\n      'ol',\n      'ul',\n      'table',\n      'thead',\n      'tfoot',\n      'tbody',\n      'caption',\n      'tr',\n      'td',\n      'th',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'blockquote',\n      'pre',\n      'address'\n    ];\n    const isList$1 = (universe, item) => {\n      const tagName = universe.property().name(item);\n      return contains$2([\n        'ol',\n        'ul'\n      ], tagName);\n    };\n    const isBlock$1 = (universe, item) => {\n      const tagName = universe.property().name(item);\n      return contains$2(blockList, tagName);\n    };\n    const isEmptyTag$1 = (universe, item) => {\n      return contains$2([\n        'br',\n        'img',\n        'hr',\n        'input'\n      ], universe.property().name(item));\n    };\n\n    const universe$1 = DomUniverse();\n    const isBlock = element => {\n      return isBlock$1(universe$1, element);\n    };\n    const isList = element => {\n      return isList$1(universe$1, element);\n    };\n    const isEmptyTag = element => {\n      return isEmptyTag$1(universe$1, element);\n    };\n\n    const merge = cells => {\n      const isBr = isTag('br');\n      const advancedBr = children => {\n        return forall(children, c => {\n          return isBr(c) || isText(c) && get$6(c).trim().length === 0;\n        });\n      };\n      const isListItem = el => {\n        return name(el) === 'li' || ancestor$2(el, isList).isSome();\n      };\n      const siblingIsBlock = el => {\n        return nextSibling(el).map(rightSibling => {\n          if (isBlock(rightSibling)) {\n            return true;\n          }\n          if (isEmptyTag(rightSibling)) {\n            return name(rightSibling) === 'img' ? false : true;\n          }\n          return false;\n        }).getOr(false);\n      };\n      const markCell = cell => {\n        return last$1(cell).bind(rightEdge => {\n          const rightSiblingIsBlock = siblingIsBlock(rightEdge);\n          return parent(rightEdge).map(parent => {\n            return rightSiblingIsBlock === true || isListItem(parent) || isBr(rightEdge) || isBlock(parent) && !eq$1(cell, parent) ? [] : [SugarElement.fromTag('br')];\n          });\n        }).getOr([]);\n      };\n      const markContent = () => {\n        const content = bind$2(cells, cell => {\n          const children = children$2(cell);\n          return advancedBr(children) ? [] : children.concat(markCell(cell));\n        });\n        return content.length === 0 ? [SugarElement.fromTag('br')] : content;\n      };\n      const contents = markContent();\n      empty(cells[0]);\n      append(cells[0], contents);\n    };\n\n    const isEditable = elem => isEditable$1(elem, true);\n    const prune = table => {\n      const cells = cells$1(table);\n      if (cells.length === 0) {\n        remove$6(table);\n      }\n    };\n    const outcome = (grid, cursor) => ({\n      grid,\n      cursor\n    });\n    const findEditableCursorPosition = rows => findMap(rows, row => findMap(row.cells, cell => {\n      const elem = cell.element;\n      return someIf(isEditable(elem), elem);\n    }));\n    const elementFromGrid = (grid, row, column) => {\n      var _a, _b;\n      const rows = extractGridDetails(grid).rows;\n      return Optional.from((_b = (_a = rows[row]) === null || _a === void 0 ? void 0 : _a.cells[column]) === null || _b === void 0 ? void 0 : _b.element).filter(isEditable).orThunk(() => findEditableCursorPosition(rows));\n    };\n    const bundle = (grid, row, column) => {\n      const cursorElement = elementFromGrid(grid, row, column);\n      return outcome(grid, cursorElement);\n    };\n    const uniqueRows = details => {\n      const rowCompilation = (rest, detail) => {\n        const rowExists = exists(rest, currentDetail => currentDetail.row === detail.row);\n        return rowExists ? rest : rest.concat([detail]);\n      };\n      return foldl(details, rowCompilation, []).sort((detailA, detailB) => detailA.row - detailB.row);\n    };\n    const opInsertRowsBefore = (grid, details, comparator, genWrappers) => {\n      const targetIndex = details[0].row;\n      const rows = uniqueRows(details);\n      const newGrid = foldr(rows, (acc, row) => {\n        const newG = insertRowAt(acc.grid, targetIndex, row.row + acc.delta, comparator, genWrappers.getOrInit);\n        return {\n          grid: newG,\n          delta: acc.delta + 1\n        };\n      }, {\n        grid,\n        delta: 0\n      }).grid;\n      return bundle(newGrid, targetIndex, details[0].column);\n    };\n    const opInsertRowsAfter = (grid, details, comparator, genWrappers) => {\n      const rows = uniqueRows(details);\n      const target = rows[rows.length - 1];\n      const targetIndex = target.row + target.rowspan;\n      const newGrid = foldr(rows, (newG, row) => {\n        return insertRowAt(newG, targetIndex, row.row, comparator, genWrappers.getOrInit);\n      }, grid);\n      return bundle(newGrid, targetIndex, details[0].column);\n    };\n    const opInsertColumnsBefore = (grid, extractDetail, comparator, genWrappers) => {\n      const details = extractDetail.details;\n      const columns = uniqueColumns(details);\n      const targetIndex = columns[0].column;\n      const newGrid = foldr(columns, (acc, col) => {\n        const newG = insertColumnAt(acc.grid, targetIndex, col.column + acc.delta, comparator, genWrappers.getOrInit);\n        return {\n          grid: newG,\n          delta: acc.delta + 1\n        };\n      }, {\n        grid,\n        delta: 0\n      }).grid;\n      return bundle(newGrid, details[0].row, targetIndex);\n    };\n    const opInsertColumnsAfter = (grid, extractDetail, comparator, genWrappers) => {\n      const details = extractDetail.details;\n      const target = details[details.length - 1];\n      const targetIndex = target.column + target.colspan;\n      const columns = uniqueColumns(details);\n      const newGrid = foldr(columns, (newG, col) => {\n        return insertColumnAt(newG, targetIndex, col.column, comparator, genWrappers.getOrInit);\n      }, grid);\n      return bundle(newGrid, details[0].row, targetIndex);\n    };\n    const opMakeColumnsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const columns = uniqueColumns(details);\n      const columnIndexes = map$1(columns, detail => detail.column);\n      const newGrid = replaceColumns(initialGrid, columnIndexes, true, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opMakeCellsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opUnmakeColumnsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const columns = uniqueColumns(details);\n      const columnIndexes = map$1(columns, detail => detail.column);\n      const newGrid = replaceColumns(initialGrid, columnIndexes, false, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opUnmakeCellsHeader = (initialGrid, details, comparator, genWrappers) => {\n      const newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const makeRowsSection = (section, applyScope) => (initialGrid, details, comparator, genWrappers, tableSection) => {\n      const rows = uniqueRows(details);\n      const rowIndexes = map$1(rows, detail => detail.row);\n      const newGrid = replaceRows(initialGrid, rowIndexes, section, applyScope, comparator, genWrappers.replaceOrInit, tableSection);\n      return bundle(newGrid, details[0].row, details[0].column);\n    };\n    const opMakeRowsHeader = makeRowsSection('thead', true);\n    const opMakeRowsBody = makeRowsSection('tbody', false);\n    const opMakeRowsFooter = makeRowsSection('tfoot', false);\n    const opEraseColumns = (grid, extractDetail, _comparator, _genWrappers) => {\n      const columns = uniqueColumns(extractDetail.details);\n      const newGrid = deleteColumnsAt(grid, map$1(columns, column => column.column));\n      const maxColIndex = newGrid.length > 0 ? newGrid[0].cells.length - 1 : 0;\n      return bundle(newGrid, columns[0].row, Math.min(columns[0].column, maxColIndex));\n    };\n    const opEraseRows = (grid, details, _comparator, _genWrappers) => {\n      const rows = uniqueRows(details);\n      const newGrid = deleteRowsAt(grid, rows[0].row, rows[rows.length - 1].row);\n      const maxRowIndex = newGrid.length > 0 ? newGrid.length - 1 : 0;\n      return bundle(newGrid, Math.min(details[0].row, maxRowIndex), details[0].column);\n    };\n    const opMergeCells = (grid, mergable, comparator, genWrappers) => {\n      const cells = mergable.cells;\n      merge(cells);\n      const newGrid = merge$2(grid, mergable.bounds, comparator, genWrappers.merge(cells));\n      return outcome(newGrid, Optional.from(cells[0]));\n    };\n    const opUnmergeCells = (grid, unmergable, comparator, genWrappers) => {\n      const unmerge$1 = (b, cell) => unmerge(b, cell, comparator, genWrappers.unmerge(cell));\n      const newGrid = foldr(unmergable, unmerge$1, grid);\n      return outcome(newGrid, Optional.from(unmergable[0]));\n    };\n    const opPasteCells = (grid, pasteDetails, comparator, _genWrappers) => {\n      const gridify = (table, generators) => {\n        const wh = Warehouse.fromTable(table);\n        return toGrid(wh, generators, true);\n      };\n      const gridB = gridify(pasteDetails.clipboard, pasteDetails.generators);\n      const startAddress = address(pasteDetails.row, pasteDetails.column);\n      const mergedGrid = merge$1(startAddress, grid, gridB, pasteDetails.generators, comparator);\n      return mergedGrid.fold(() => outcome(grid, Optional.some(pasteDetails.element)), newGrid => {\n        return bundle(newGrid, pasteDetails.row, pasteDetails.column);\n      });\n    };\n    const gridifyRows = (rows, generators, context) => {\n      const pasteDetails = fromPastedRows(rows, context.section);\n      const wh = Warehouse.generate(pasteDetails);\n      return toGrid(wh, generators, true);\n    };\n    const opPasteColsBefore = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[0].column;\n      const context = rows[pasteDetails.cells[0].row];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertCols(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opPasteColsAfter = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[pasteDetails.cells.length - 1].column + pasteDetails.cells[pasteDetails.cells.length - 1].colspan;\n      const context = rows[pasteDetails.cells[0].row];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertCols(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opPasteRowsBefore = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[0].row;\n      const context = rows[index];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertRows(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opPasteRowsAfter = (grid, pasteDetails, comparator, _genWrappers) => {\n      const rows = extractGridDetails(grid).rows;\n      const index = pasteDetails.cells[pasteDetails.cells.length - 1].row + pasteDetails.cells[pasteDetails.cells.length - 1].rowspan;\n      const context = rows[pasteDetails.cells[0].row];\n      const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);\n      const mergedGrid = insertRows(index, grid, gridB, pasteDetails.generators, comparator);\n      return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);\n    };\n    const opGetColumnsType = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onCells(house, target);\n      return details.bind(selectedCells => {\n        const lastSelectedCell = selectedCells[selectedCells.length - 1];\n        const minColRange = selectedCells[0].column;\n        const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;\n        const selectedColumnCells = flatten(map$1(house.all, row => filter$2(row.cells, cell => cell.column >= minColRange && cell.column < maxColRange)));\n        return findCommonCellType(selectedColumnCells);\n      }).getOr('');\n    };\n    const opGetCellsType = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onCells(house, target);\n      return details.bind(findCommonCellType).getOr('');\n    };\n    const opGetRowsType = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onCells(house, target);\n      return details.bind(selectedCells => {\n        const lastSelectedCell = selectedCells[selectedCells.length - 1];\n        const minRowRange = selectedCells[0].row;\n        const maxRowRange = lastSelectedCell.row + lastSelectedCell.rowspan;\n        const selectedRows = house.all.slice(minRowRange, maxRowRange);\n        return findCommonRowType(selectedRows);\n      }).getOr('');\n    };\n    const resize = (table, list, details, behaviours) => adjustWidthTo(table, list, details, behaviours.sizing);\n    const adjustAndRedistributeWidths = (table, list, details, behaviours) => adjustAndRedistributeWidths$1(table, list, details, behaviours.sizing, behaviours.resize);\n    const firstColumnIsLocked = (_warehouse, details) => exists(details, detail => detail.column === 0 && detail.isLocked);\n    const lastColumnIsLocked = (warehouse, details) => exists(details, detail => detail.column + detail.colspan >= warehouse.grid.columns && detail.isLocked);\n    const getColumnsWidth = (warehouse, details) => {\n      const columns$1 = columns(warehouse);\n      const uniqueCols = uniqueColumns(details);\n      return foldl(uniqueCols, (acc, detail) => {\n        const column = columns$1[detail.column];\n        const colWidth = column.map(getOuter$2).getOr(0);\n        return acc + colWidth;\n      }, 0);\n    };\n    const insertColumnsExtractor = before => (warehouse, target) => onCells(warehouse, target).filter(details => {\n      const checkLocked = before ? firstColumnIsLocked : lastColumnIsLocked;\n      return !checkLocked(warehouse, details);\n    }).map(details => ({\n      details,\n      pixelDelta: getColumnsWidth(warehouse, details)\n    }));\n    const eraseColumnsExtractor = (warehouse, target) => onUnlockedCells(warehouse, target).map(details => ({\n      details,\n      pixelDelta: -getColumnsWidth(warehouse, details)\n    }));\n    const pasteColumnsExtractor = before => (warehouse, target) => onPasteByEditor(warehouse, target).filter(details => {\n      const checkLocked = before ? firstColumnIsLocked : lastColumnIsLocked;\n      return !checkLocked(warehouse, details.cells);\n    });\n    const headerCellGenerator = Generators.transform('th');\n    const bodyCellGenerator = Generators.transform('td');\n    const insertRowsBefore = run(opInsertRowsBefore, onCells, noop, noop, Generators.modification);\n    const insertRowsAfter = run(opInsertRowsAfter, onCells, noop, noop, Generators.modification);\n    const insertColumnsBefore = run(opInsertColumnsBefore, insertColumnsExtractor(true), adjustAndRedistributeWidths, noop, Generators.modification);\n    const insertColumnsAfter = run(opInsertColumnsAfter, insertColumnsExtractor(false), adjustAndRedistributeWidths, noop, Generators.modification);\n    const eraseColumns = run(opEraseColumns, eraseColumnsExtractor, adjustAndRedistributeWidths, prune, Generators.modification);\n    const eraseRows = run(opEraseRows, onCells, noop, prune, Generators.modification);\n    const makeColumnsHeader = run(opMakeColumnsHeader, onUnlockedCells, noop, noop, headerCellGenerator);\n    const unmakeColumnsHeader = run(opUnmakeColumnsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const makeRowsHeader = run(opMakeRowsHeader, onUnlockedCells, noop, noop, headerCellGenerator);\n    const makeRowsBody = run(opMakeRowsBody, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const makeRowsFooter = run(opMakeRowsFooter, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const makeCellsHeader = run(opMakeCellsHeader, onUnlockedCells, noop, noop, headerCellGenerator);\n    const unmakeCellsHeader = run(opUnmakeCellsHeader, onUnlockedCells, noop, noop, bodyCellGenerator);\n    const mergeCells = run(opMergeCells, onUnlockedMergable, resize, noop, Generators.merging);\n    const unmergeCells = run(opUnmergeCells, onUnlockedUnmergable, resize, noop, Generators.merging);\n    const pasteCells = run(opPasteCells, onPaste, resize, noop, Generators.modification);\n    const pasteColsBefore = run(opPasteColsBefore, pasteColumnsExtractor(true), noop, noop, Generators.modification);\n    const pasteColsAfter = run(opPasteColsAfter, pasteColumnsExtractor(false), noop, noop, Generators.modification);\n    const pasteRowsBefore = run(opPasteRowsBefore, onPasteByEditor, noop, noop, Generators.modification);\n    const pasteRowsAfter = run(opPasteRowsAfter, onPasteByEditor, noop, noop, Generators.modification);\n    const getColumnsType = opGetColumnsType;\n    const getCellsType = opGetCellsType;\n    const getRowsType = opGetRowsType;\n\n    const fireNewRow = (editor, row) => editor.dispatch('NewRow', { node: row });\n    const fireNewCell = (editor, cell) => editor.dispatch('NewCell', { node: cell });\n    const fireTableModified = (editor, table, data) => {\n      editor.dispatch('TableModified', {\n        ...data,\n        table\n      });\n    };\n    const fireTableSelectionChange = (editor, cells, start, finish, otherCells) => {\n      editor.dispatch('TableSelectionChange', {\n        cells,\n        start,\n        finish,\n        otherCells\n      });\n    };\n    const fireTableSelectionClear = editor => {\n      editor.dispatch('TableSelectionClear');\n    };\n    const fireObjectResizeStart = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResizeStart', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const fireObjectResized = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResized', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const styleModified = {\n      structure: false,\n      style: true\n    };\n    const structureModified = {\n      structure: true,\n      style: false\n    };\n    const styleAndStructureModified = {\n      structure: true,\n      style: true\n    };\n\n    const option = name => editor => editor.options.get(name);\n    const defaultWidth = '100%';\n    const getPixelForcedWidth = editor => {\n      var _a;\n      const dom = editor.dom;\n      const parentBlock = (_a = dom.getParent(editor.selection.getStart(), dom.isBlock)) !== null && _a !== void 0 ? _a : editor.getBody();\n      return getInner(SugarElement.fromDom(parentBlock)) + 'px';\n    };\n    const determineDefaultTableStyles = (editor, defaultStyles) => {\n      if (isTableResponsiveForced(editor) || !shouldStyleWithCss(editor)) {\n        return defaultStyles;\n      } else if (isTablePixelsForced(editor)) {\n        return {\n          ...defaultStyles,\n          width: getPixelForcedWidth(editor)\n        };\n      } else {\n        return {\n          ...defaultStyles,\n          width: defaultWidth\n        };\n      }\n    };\n    const determineDefaultTableAttributes = (editor, defaultAttributes) => {\n      if (isTableResponsiveForced(editor) || shouldStyleWithCss(editor)) {\n        return defaultAttributes;\n      } else if (isTablePixelsForced(editor)) {\n        return {\n          ...defaultAttributes,\n          width: getPixelForcedWidth(editor)\n        };\n      } else {\n        return {\n          ...defaultAttributes,\n          width: defaultWidth\n        };\n      }\n    };\n    const register = editor => {\n      const registerOption = editor.options.register;\n      registerOption('table_clone_elements', { processor: 'string[]' });\n      registerOption('table_use_colgroups', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('table_header_type', {\n        processor: value => {\n          const valid = contains$2([\n            'section',\n            'cells',\n            'sectionCells',\n            'auto'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: section, cells, sectionCells or auto.'\n          };\n        },\n        default: 'section'\n      });\n      registerOption('table_sizing_mode', {\n        processor: 'string',\n        default: 'auto'\n      });\n      registerOption('table_default_attributes', {\n        processor: 'object',\n        default: { border: '1' }\n      });\n      registerOption('table_default_styles', {\n        processor: 'object',\n        default: { 'border-collapse': 'collapse' }\n      });\n      registerOption('table_column_resizing', {\n        processor: value => {\n          const valid = contains$2([\n            'preservetable',\n            'resizetable'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be preservetable, or resizetable.'\n          };\n        },\n        default: 'preservetable'\n      });\n      registerOption('table_resize_bars', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('table_style_by_css', {\n        processor: 'boolean',\n        default: true\n      });\n    };\n    const getTableCloneElements = editor => {\n      return Optional.from(editor.options.get('table_clone_elements'));\n    };\n    const hasTableObjectResizing = editor => {\n      const objectResizing = editor.options.get('object_resizing');\n      return contains$2(objectResizing.split(','), 'table');\n    };\n    const getTableHeaderType = option('table_header_type');\n    const getTableColumnResizingBehaviour = option('table_column_resizing');\n    const isPreserveTableColumnResizing = editor => getTableColumnResizingBehaviour(editor) === 'preservetable';\n    const isResizeTableColumnResizing = editor => getTableColumnResizingBehaviour(editor) === 'resizetable';\n    const getTableSizingMode = option('table_sizing_mode');\n    const isTablePercentagesForced = editor => getTableSizingMode(editor) === 'relative';\n    const isTablePixelsForced = editor => getTableSizingMode(editor) === 'fixed';\n    const isTableResponsiveForced = editor => getTableSizingMode(editor) === 'responsive';\n    const hasTableResizeBars = option('table_resize_bars');\n    const shouldStyleWithCss = option('table_style_by_css');\n    const getTableDefaultAttributes = editor => {\n      const options = editor.options;\n      const defaultAttributes = options.get('table_default_attributes');\n      return options.isSet('table_default_attributes') ? defaultAttributes : determineDefaultTableAttributes(editor, defaultAttributes);\n    };\n    const getTableDefaultStyles = editor => {\n      const options = editor.options;\n      const defaultStyles = options.get('table_default_styles');\n      return options.isSet('table_default_styles') ? defaultStyles : determineDefaultTableStyles(editor, defaultStyles);\n    };\n    const tableUseColumnGroup = option('table_use_colgroups');\n\n    const get$5 = (editor, table) => {\n      if (isTablePercentagesForced(editor)) {\n        return TableSize.percentageSize(table);\n      } else if (isTablePixelsForced(editor)) {\n        return TableSize.pixelSize(table);\n      } else {\n        return TableSize.getTableSize(table);\n      }\n    };\n\n    const TableActions = (editor, resizeHandler, cellSelectionHandler) => {\n      const isTableBody = editor => name(getBody(editor)) === 'table';\n      const lastRowGuard = table => isTableBody(editor) === false || getGridSize(table).rows > 1;\n      const lastColumnGuard = table => isTableBody(editor) === false || getGridSize(table).columns > 1;\n      const cloneFormats = getTableCloneElements(editor);\n      const colMutationOp = isResizeTableColumnResizing(editor) ? noop : halve;\n      const getTableSectionType = table => {\n        switch (getTableHeaderType(editor)) {\n        case 'section':\n          return TableSection.section();\n        case 'sectionCells':\n          return TableSection.sectionCells();\n        case 'cells':\n          return TableSection.cells();\n        default:\n          return TableSection.getTableSectionType(table, 'section');\n        }\n      };\n      const setSelectionFromAction = (table, result) => result.cursor.fold(() => {\n        const cells = cells$1(table);\n        return head(cells).filter(inBody).map(firstCell => {\n          cellSelectionHandler.clearSelectedCells(table.dom);\n          const rng = editor.dom.createRng();\n          rng.selectNode(firstCell.dom);\n          editor.selection.setRng(rng);\n          set$2(firstCell, 'data-mce-selected', '1');\n          return rng;\n        });\n      }, cell => {\n        const des = freefallRtl(cell);\n        const rng = editor.dom.createRng();\n        rng.setStart(des.element.dom, des.offset);\n        rng.setEnd(des.element.dom, des.offset);\n        editor.selection.setRng(rng);\n        cellSelectionHandler.clearSelectedCells(table.dom);\n        return Optional.some(rng);\n      });\n      const execute = (operation, guard, mutate, effect) => (table, target, noEvents = false) => {\n        removeDataStyle(table);\n        const doc = SugarElement.fromDom(editor.getDoc());\n        const generators = cellOperations(mutate, doc, cloneFormats);\n        const behaviours = {\n          sizing: get$5(editor, table),\n          resize: isResizeTableColumnResizing(editor) ? resizeTable() : preserveTable(),\n          section: getTableSectionType(table)\n        };\n        return guard(table) ? operation(table, target, generators, behaviours).bind(result => {\n          resizeHandler.refresh(table.dom);\n          each$2(result.newRows, row => {\n            fireNewRow(editor, row.dom);\n          });\n          each$2(result.newCells, cell => {\n            fireNewCell(editor, cell.dom);\n          });\n          const range = setSelectionFromAction(table, result);\n          if (inBody(table)) {\n            removeDataStyle(table);\n            if (!noEvents) {\n              fireTableModified(editor, table.dom, effect);\n            }\n          }\n          return range.map(rng => ({\n            rng,\n            effect\n          }));\n        }) : Optional.none();\n      };\n      const deleteRow = execute(eraseRows, lastRowGuard, noop, structureModified);\n      const deleteColumn = execute(eraseColumns, lastColumnGuard, noop, structureModified);\n      const insertRowsBefore$1 = execute(insertRowsBefore, always, noop, structureModified);\n      const insertRowsAfter$1 = execute(insertRowsAfter, always, noop, structureModified);\n      const insertColumnsBefore$1 = execute(insertColumnsBefore, always, colMutationOp, structureModified);\n      const insertColumnsAfter$1 = execute(insertColumnsAfter, always, colMutationOp, structureModified);\n      const mergeCells$1 = execute(mergeCells, always, noop, structureModified);\n      const unmergeCells$1 = execute(unmergeCells, always, noop, structureModified);\n      const pasteColsBefore$1 = execute(pasteColsBefore, always, noop, structureModified);\n      const pasteColsAfter$1 = execute(pasteColsAfter, always, noop, structureModified);\n      const pasteRowsBefore$1 = execute(pasteRowsBefore, always, noop, structureModified);\n      const pasteRowsAfter$1 = execute(pasteRowsAfter, always, noop, structureModified);\n      const pasteCells$1 = execute(pasteCells, always, noop, styleAndStructureModified);\n      const makeCellsHeader$1 = execute(makeCellsHeader, always, noop, structureModified);\n      const unmakeCellsHeader$1 = execute(unmakeCellsHeader, always, noop, structureModified);\n      const makeColumnsHeader$1 = execute(makeColumnsHeader, always, noop, structureModified);\n      const unmakeColumnsHeader$1 = execute(unmakeColumnsHeader, always, noop, structureModified);\n      const makeRowsHeader$1 = execute(makeRowsHeader, always, noop, structureModified);\n      const makeRowsBody$1 = execute(makeRowsBody, always, noop, structureModified);\n      const makeRowsFooter$1 = execute(makeRowsFooter, always, noop, structureModified);\n      const getTableCellType = getCellsType;\n      const getTableColType = getColumnsType;\n      const getTableRowType = getRowsType;\n      return {\n        deleteRow,\n        deleteColumn,\n        insertRowsBefore: insertRowsBefore$1,\n        insertRowsAfter: insertRowsAfter$1,\n        insertColumnsBefore: insertColumnsBefore$1,\n        insertColumnsAfter: insertColumnsAfter$1,\n        mergeCells: mergeCells$1,\n        unmergeCells: unmergeCells$1,\n        pasteColsBefore: pasteColsBefore$1,\n        pasteColsAfter: pasteColsAfter$1,\n        pasteRowsBefore: pasteRowsBefore$1,\n        pasteRowsAfter: pasteRowsAfter$1,\n        pasteCells: pasteCells$1,\n        makeCellsHeader: makeCellsHeader$1,\n        unmakeCellsHeader: unmakeCellsHeader$1,\n        makeColumnsHeader: makeColumnsHeader$1,\n        unmakeColumnsHeader: unmakeColumnsHeader$1,\n        makeRowsHeader: makeRowsHeader$1,\n        makeRowsBody: makeRowsBody$1,\n        makeRowsFooter: makeRowsFooter$1,\n        getTableRowType,\n        getTableCellType,\n        getTableColType\n      };\n    };\n\n    const constrainSpan = (element, property, value) => {\n      const currentColspan = getAttrValue(element, property, 1);\n      if (value === 1 || currentColspan <= 1) {\n        remove$7(element, property);\n      } else {\n        set$2(element, property, Math.min(value, currentColspan));\n      }\n    };\n    const isColInRange = (minColRange, maxColRange) => cell => {\n      const endCol = cell.column + cell.colspan - 1;\n      const startCol = cell.column;\n      return endCol >= minColRange && startCol < maxColRange;\n    };\n    const generateColGroup = (house, minColRange, maxColRange) => {\n      if (Warehouse.hasColumns(house)) {\n        const colsToCopy = filter$2(Warehouse.justColumns(house), isColInRange(minColRange, maxColRange));\n        const copiedCols = map$1(colsToCopy, c => {\n          const clonedCol = deep(c.element);\n          constrainSpan(clonedCol, 'span', maxColRange - minColRange);\n          return clonedCol;\n        });\n        const fakeColgroup = SugarElement.fromTag('colgroup');\n        append(fakeColgroup, copiedCols);\n        return [fakeColgroup];\n      } else {\n        return [];\n      }\n    };\n    const generateRows = (house, minColRange, maxColRange) => map$1(house.all, row => {\n      const cellsToCopy = filter$2(row.cells, isColInRange(minColRange, maxColRange));\n      const copiedCells = map$1(cellsToCopy, cell => {\n        const clonedCell = deep(cell.element);\n        constrainSpan(clonedCell, 'colspan', maxColRange - minColRange);\n        return clonedCell;\n      });\n      const fakeTR = SugarElement.fromTag('tr');\n      append(fakeTR, copiedCells);\n      return fakeTR;\n    });\n    const copyCols = (table, target) => {\n      const house = Warehouse.fromTable(table);\n      const details = onUnlockedCells(house, target);\n      return details.map(selectedCells => {\n        const lastSelectedCell = selectedCells[selectedCells.length - 1];\n        const minColRange = selectedCells[0].column;\n        const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;\n        const fakeColGroups = generateColGroup(house, minColRange, maxColRange);\n        const fakeRows = generateRows(house, minColRange, maxColRange);\n        return [\n          ...fakeColGroups,\n          ...fakeRows\n        ];\n      });\n    };\n\n    const copyRows = (table, target, generators) => {\n      const warehouse = Warehouse.fromTable(table);\n      const details = onCells(warehouse, target);\n      return details.bind(selectedCells => {\n        const grid = toGrid(warehouse, generators, false);\n        const rows = extractGridDetails(grid).rows;\n        const slicedGrid = rows.slice(selectedCells[0].row, selectedCells[selectedCells.length - 1].row + selectedCells[selectedCells.length - 1].rowspan);\n        const filteredGrid = bind$2(slicedGrid, row => {\n          const newCells = filter$2(row.cells, cell => !cell.isLocked);\n          return newCells.length > 0 ? [{\n              ...row,\n              cells: newCells\n            }] : [];\n        });\n        const slicedDetails = toDetailList(filteredGrid);\n        return someIf(slicedDetails.length > 0, slicedDetails);\n      }).map(slicedDetails => copy(slicedDetails));\n    };\n\n    const adt$5 = Adt.generate([\n      { invalid: ['raw'] },\n      { pixels: ['value'] },\n      { percent: ['value'] }\n    ]);\n    const validateFor = (suffix, type, value) => {\n      const rawAmount = value.substring(0, value.length - suffix.length);\n      const amount = parseFloat(rawAmount);\n      return rawAmount === amount.toString() ? type(amount) : adt$5.invalid(value);\n    };\n    const from = value => {\n      if (endsWith(value, '%')) {\n        return validateFor('%', adt$5.percent, value);\n      }\n      if (endsWith(value, 'px')) {\n        return validateFor('px', adt$5.pixels, value);\n      }\n      return adt$5.invalid(value);\n    };\n    const Size = {\n      ...adt$5,\n      from\n    };\n\n    const redistributeToPercent = (widths, totalWidth) => {\n      return map$1(widths, w => {\n        const colType = Size.from(w);\n        return colType.fold(() => {\n          return w;\n        }, px => {\n          const ratio = px / totalWidth * 100;\n          return ratio + '%';\n        }, pc => {\n          return pc + '%';\n        });\n      });\n    };\n    const redistributeToPx = (widths, totalWidth, newTotalWidth) => {\n      const scale = newTotalWidth / totalWidth;\n      return map$1(widths, w => {\n        const colType = Size.from(w);\n        return colType.fold(() => {\n          return w;\n        }, px => {\n          return px * scale + 'px';\n        }, pc => {\n          return pc / 100 * newTotalWidth + 'px';\n        });\n      });\n    };\n    const redistributeEmpty = (newWidthType, columns) => {\n      const f = newWidthType.fold(() => constant(''), pixels => {\n        const num = pixels / columns;\n        return constant(num + 'px');\n      }, () => {\n        const num = 100 / columns;\n        return constant(num + '%');\n      });\n      return range$1(columns, f);\n    };\n    const redistributeValues = (newWidthType, widths, totalWidth) => {\n      return newWidthType.fold(() => {\n        return widths;\n      }, px => {\n        return redistributeToPx(widths, totalWidth, px);\n      }, _pc => {\n        return redistributeToPercent(widths, totalWidth);\n      });\n    };\n    const redistribute$1 = (widths, totalWidth, newWidth) => {\n      const newType = Size.from(newWidth);\n      const floats = forall(widths, s => {\n        return s === '0px';\n      }) ? redistributeEmpty(newType, widths.length) : redistributeValues(newType, widths, totalWidth);\n      return normalize(floats);\n    };\n    const sum = (values, fallback) => {\n      if (values.length === 0) {\n        return fallback;\n      }\n      return foldr(values, (rest, v) => {\n        return Size.from(v).fold(constant(0), identity, identity) + rest;\n      }, 0);\n    };\n    const roundDown = (num, unit) => {\n      const floored = Math.floor(num);\n      return {\n        value: floored + unit,\n        remainder: num - floored\n      };\n    };\n    const add$3 = (value, amount) => {\n      return Size.from(value).fold(constant(value), px => {\n        return px + amount + 'px';\n      }, pc => {\n        return pc + amount + '%';\n      });\n    };\n    const normalize = values => {\n      if (values.length === 0) {\n        return values;\n      }\n      const scan = foldr(values, (rest, value) => {\n        const info = Size.from(value).fold(() => ({\n          value,\n          remainder: 0\n        }), num => roundDown(num, 'px'), num => ({\n          value: num + '%',\n          remainder: 0\n        }));\n        return {\n          output: [info.value].concat(rest.output),\n          remainder: rest.remainder + info.remainder\n        };\n      }, {\n        output: [],\n        remainder: 0\n      });\n      const r = scan.output;\n      return r.slice(0, r.length - 1).concat([add$3(r[r.length - 1], Math.round(scan.remainder))]);\n    };\n    const validate = Size.from;\n\n    const redistributeToW = (newWidths, cells, unit) => {\n      each$2(cells, cell => {\n        const widths = newWidths.slice(cell.column, cell.colspan + cell.column);\n        const w = sum(widths, minWidth());\n        set$1(cell.element, 'width', w + unit);\n      });\n    };\n    const redistributeToColumns = (newWidths, columns, unit) => {\n      each$2(columns, (column, index) => {\n        const width = sum([newWidths[index]], minWidth());\n        set$1(column.element, 'width', width + unit);\n      });\n    };\n    const redistributeToH = (newHeights, rows, cells, unit) => {\n      each$2(cells, cell => {\n        const heights = newHeights.slice(cell.row, cell.rowspan + cell.row);\n        const h = sum(heights, minHeight());\n        set$1(cell.element, 'height', h + unit);\n      });\n      each$2(rows, (row, i) => {\n        set$1(row.element, 'height', newHeights[i]);\n      });\n    };\n    const getUnit = newSize => {\n      return validate(newSize).fold(constant('px'), constant('px'), constant('%'));\n    };\n    const redistribute = (table, optWidth, optHeight) => {\n      const warehouse = Warehouse.fromTable(table);\n      const rows = warehouse.all;\n      const cells = Warehouse.justCells(warehouse);\n      const columns = Warehouse.justColumns(warehouse);\n      optWidth.each(newWidth => {\n        const widthUnit = getUnit(newWidth);\n        const totalWidth = get$9(table);\n        const oldWidths = getRawWidths(warehouse, table);\n        const nuWidths = redistribute$1(oldWidths, totalWidth, newWidth);\n        if (Warehouse.hasColumns(warehouse)) {\n          redistributeToColumns(nuWidths, columns, widthUnit);\n        } else {\n          redistributeToW(nuWidths, cells, widthUnit);\n        }\n        set$1(table, 'width', newWidth);\n      });\n      optHeight.each(newHeight => {\n        const hUnit = getUnit(newHeight);\n        const totalHeight = get$8(table);\n        const oldHeights = getRawHeights(warehouse, table, height);\n        const nuHeights = redistribute$1(oldHeights, totalHeight, newHeight);\n        redistributeToH(nuHeights, rows, cells, hUnit);\n        set$1(table, 'height', newHeight);\n      });\n    };\n    const isPercentSizing = isPercentSizing$1;\n    const isPixelSizing = isPixelSizing$1;\n    const isNoneSizing = isNoneSizing$1;\n\n    const cleanupLegacyAttributes = element => {\n      remove$7(element, 'width');\n    };\n    const convertToPercentSize = table => {\n      const newWidth = getPercentTableWidth(table);\n      redistribute(table, Optional.some(newWidth), Optional.none());\n      cleanupLegacyAttributes(table);\n    };\n    const convertToPixelSize = table => {\n      const newWidth = getPixelTableWidth(table);\n      redistribute(table, Optional.some(newWidth), Optional.none());\n      cleanupLegacyAttributes(table);\n    };\n    const convertToNoneSize = table => {\n      remove$5(table, 'width');\n      const columns = columns$1(table);\n      const rowElements = columns.length > 0 ? columns : cells$1(table);\n      each$2(rowElements, cell => {\n        remove$5(cell, 'width');\n        cleanupLegacyAttributes(cell);\n      });\n      cleanupLegacyAttributes(table);\n    };\n\n    const DefaultRenderOptions = {\n      styles: {\n        'border-collapse': 'collapse',\n        'width': '100%'\n      },\n      attributes: { border: '1' },\n      colGroups: false\n    };\n    const tableHeaderCell = () => SugarElement.fromTag('th');\n    const tableCell = () => SugarElement.fromTag('td');\n    const tableColumn = () => SugarElement.fromTag('col');\n    const createRow = (columns, rowHeaders, columnHeaders, rowIndex) => {\n      const tr = SugarElement.fromTag('tr');\n      for (let j = 0; j < columns; j++) {\n        const td = rowIndex < rowHeaders || j < columnHeaders ? tableHeaderCell() : tableCell();\n        if (j < columnHeaders) {\n          set$2(td, 'scope', 'row');\n        }\n        if (rowIndex < rowHeaders) {\n          set$2(td, 'scope', 'col');\n        }\n        append$1(td, SugarElement.fromTag('br'));\n        append$1(tr, td);\n      }\n      return tr;\n    };\n    const createGroupRow = columns => {\n      const columnGroup = SugarElement.fromTag('colgroup');\n      range$1(columns, () => append$1(columnGroup, tableColumn()));\n      return columnGroup;\n    };\n    const createRows = (rows, columns, rowHeaders, columnHeaders) => range$1(rows, r => createRow(columns, rowHeaders, columnHeaders, r));\n    const render = (rows, columns, rowHeaders, columnHeaders, headerType, renderOpts = DefaultRenderOptions) => {\n      const table = SugarElement.fromTag('table');\n      const rowHeadersGoInThead = headerType !== 'cells';\n      setAll(table, renderOpts.styles);\n      setAll$1(table, renderOpts.attributes);\n      if (renderOpts.colGroups) {\n        append$1(table, createGroupRow(columns));\n      }\n      const actualRowHeaders = Math.min(rows, rowHeaders);\n      if (rowHeadersGoInThead && rowHeaders > 0) {\n        const thead = SugarElement.fromTag('thead');\n        append$1(table, thead);\n        const theadRowHeaders = headerType === 'sectionCells' ? actualRowHeaders : 0;\n        const theadRows = createRows(rowHeaders, columns, theadRowHeaders, columnHeaders);\n        append(thead, theadRows);\n      }\n      const tbody = SugarElement.fromTag('tbody');\n      append$1(table, tbody);\n      const numRows = rowHeadersGoInThead ? rows - actualRowHeaders : rows;\n      const numRowHeaders = rowHeadersGoInThead ? 0 : rowHeaders;\n      const tbodyRows = createRows(numRows, columns, numRowHeaders, columnHeaders);\n      append(tbody, tbodyRows);\n      return table;\n    };\n\n    const get$4 = element => element.dom.innerHTML;\n    const getOuter = element => {\n      const container = SugarElement.fromTag('div');\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n      append$1(container, clone);\n      return get$4(container);\n    };\n\n    const placeCaretInCell = (editor, cell) => {\n      editor.selection.select(cell.dom, true);\n      editor.selection.collapse(true);\n    };\n    const selectFirstCellInTable = (editor, tableElm) => {\n      descendant(tableElm, 'td,th').each(curry(placeCaretInCell, editor));\n    };\n    const fireEvents = (editor, table) => {\n      each$2(descendants(table, 'tr'), row => {\n        fireNewRow(editor, row.dom);\n        each$2(descendants(row, 'th,td'), cell => {\n          fireNewCell(editor, cell.dom);\n        });\n      });\n    };\n    const isPercentage = width => isString(width) && width.indexOf('%') !== -1;\n    const insert = (editor, columns, rows, colHeaders, rowHeaders) => {\n      const defaultStyles = getTableDefaultStyles(editor);\n      const options = {\n        styles: defaultStyles,\n        attributes: getTableDefaultAttributes(editor),\n        colGroups: tableUseColumnGroup(editor)\n      };\n      editor.undoManager.ignore(() => {\n        const table = render(rows, columns, rowHeaders, colHeaders, getTableHeaderType(editor), options);\n        set$2(table, 'data-mce-id', '__mce');\n        const html = getOuter(table);\n        editor.insertContent(html);\n        editor.addVisual();\n      });\n      return descendant(getBody(editor), 'table[data-mce-id=\"__mce\"]').map(table => {\n        if (isTablePixelsForced(editor)) {\n          convertToPixelSize(table);\n        } else if (isTableResponsiveForced(editor)) {\n          convertToNoneSize(table);\n        } else if (isTablePercentagesForced(editor) || isPercentage(defaultStyles.width)) {\n          convertToPercentSize(table);\n        }\n        removeDataStyle(table);\n        remove$7(table, 'data-mce-id');\n        fireEvents(editor, table);\n        selectFirstCellInTable(editor, table);\n        return table.dom;\n      }).getOr(null);\n    };\n    const insertTable = (editor, rows, columns, options = {}) => {\n      const checkInput = val => isNumber(val) && val > 0;\n      if (checkInput(rows) && checkInput(columns)) {\n        const headerRows = options.headerRows || 0;\n        const headerColumns = options.headerColumns || 0;\n        return insert(editor, columns, rows, headerColumns, headerRows);\n      } else {\n        console.error('Invalid values for mceInsertTable - rows and columns values are required to insert a table.');\n        return null;\n      }\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.FakeClipboard');\n\n    const tableTypeBase = 'x-tinymce/dom-table-';\n    const tableTypeRow = tableTypeBase + 'rows';\n    const tableTypeColumn = tableTypeBase + 'columns';\n    const setData = items => {\n      const fakeClipboardItem = global.FakeClipboardItem(items);\n      global.write([fakeClipboardItem]);\n    };\n    const getData = type => {\n      var _a;\n      const items = (_a = global.read()) !== null && _a !== void 0 ? _a : [];\n      return findMap(items, item => Optional.from(item.getType(type)));\n    };\n    const clearData = type => {\n      if (getData(type).isSome()) {\n        global.clear();\n      }\n    };\n    const setRows = rowsOpt => {\n      rowsOpt.fold(clearRows, rows => setData({ [tableTypeRow]: rows }));\n    };\n    const getRows = () => getData(tableTypeRow);\n    const clearRows = () => clearData(tableTypeRow);\n    const setColumns = columnsOpt => {\n      columnsOpt.fold(clearColumns, columns => setData({ [tableTypeColumn]: columns }));\n    };\n    const getColumns = () => getData(tableTypeColumn);\n    const clearColumns = () => clearData(tableTypeColumn);\n\n    const getSelectionStartCellOrCaption = editor => getSelectionCellOrCaption(getSelectionStart(editor), getIsRoot(editor));\n    const getSelectionStartCell = editor => getSelectionCell(getSelectionStart(editor), getIsRoot(editor));\n    const registerCommands = (editor, actions) => {\n      const isRoot = getIsRoot(editor);\n      const eraseTable = () => getSelectionStartCellOrCaption(editor).each(cellOrCaption => {\n        table(cellOrCaption, isRoot).filter(not(isRoot)).each(table => {\n          const cursor = SugarElement.fromText('');\n          after$5(table, cursor);\n          remove$6(table);\n          if (editor.dom.isEmpty(editor.getBody())) {\n            editor.setContent('');\n            editor.selection.setCursorLocation();\n          } else {\n            const rng = editor.dom.createRng();\n            rng.setStart(cursor.dom, 0);\n            rng.setEnd(cursor.dom, 0);\n            editor.selection.setRng(rng);\n            editor.nodeChanged();\n          }\n        });\n      });\n      const setSizingMode = sizing => getSelectionStartCellOrCaption(editor).each(cellOrCaption => {\n        const isForcedSizing = isTableResponsiveForced(editor) || isTablePixelsForced(editor) || isTablePercentagesForced(editor);\n        if (!isForcedSizing) {\n          table(cellOrCaption, isRoot).each(table => {\n            if (sizing === 'relative' && !isPercentSizing(table)) {\n              convertToPercentSize(table);\n            } else if (sizing === 'fixed' && !isPixelSizing(table)) {\n              convertToPixelSize(table);\n            } else if (sizing === 'responsive' && !isNoneSizing(table)) {\n              convertToNoneSize(table);\n            }\n            removeDataStyle(table);\n            fireTableModified(editor, table.dom, structureModified);\n          });\n        }\n      });\n      const getTableFromCell = cell => table(cell, isRoot);\n      const performActionOnSelection = action => getSelectionStartCell(editor).bind(cell => getTableFromCell(cell).map(table => action(table, cell)));\n      const toggleTableClass = (_ui, clazz) => {\n        performActionOnSelection(table => {\n          editor.formatter.toggle('tableclass', { value: clazz }, table.dom);\n          fireTableModified(editor, table.dom, styleModified);\n        });\n      };\n      const toggleTableCellClass = (_ui, clazz) => {\n        performActionOnSelection(table => {\n          const selectedCells = getCellsFromSelection(editor);\n          const allHaveClass = forall(selectedCells, cell => editor.formatter.match('tablecellclass', { value: clazz }, cell.dom));\n          const formatterAction = allHaveClass ? editor.formatter.remove : editor.formatter.apply;\n          each$2(selectedCells, cell => formatterAction('tablecellclass', { value: clazz }, cell.dom));\n          fireTableModified(editor, table.dom, styleModified);\n        });\n      };\n      const toggleCaption = () => {\n        getSelectionStartCellOrCaption(editor).each(cellOrCaption => {\n          table(cellOrCaption, isRoot).each(table => {\n            child(table, 'caption').fold(() => {\n              const caption = SugarElement.fromTag('caption');\n              append$1(caption, SugarElement.fromText('Caption'));\n              appendAt(table, caption, 0);\n              editor.selection.setCursorLocation(caption.dom, 0);\n            }, caption => {\n              if (isTag('caption')(cellOrCaption)) {\n                one('td', table).each(td => editor.selection.setCursorLocation(td.dom, 0));\n              }\n              remove$6(caption);\n            });\n            fireTableModified(editor, table.dom, structureModified);\n          });\n        });\n      };\n      const postExecute = _data => {\n        editor.focus();\n      };\n      const actOnSelection = (execute, noEvents = false) => performActionOnSelection((table, startCell) => {\n        const targets = forMenu(getCellsFromSelection(editor), table, startCell);\n        execute(table, targets, noEvents).each(postExecute);\n      });\n      const copyRowSelection = () => performActionOnSelection((table, startCell) => {\n        const targets = forMenu(getCellsFromSelection(editor), table, startCell);\n        const generators = cellOperations(noop, SugarElement.fromDom(editor.getDoc()), Optional.none());\n        return copyRows(table, targets, generators);\n      });\n      const copyColSelection = () => performActionOnSelection((table, startCell) => {\n        const targets = forMenu(getCellsFromSelection(editor), table, startCell);\n        return copyCols(table, targets);\n      });\n      const pasteOnSelection = (execute, getRows) => getRows().each(rows => {\n        const clonedRows = map$1(rows, row => deep(row));\n        performActionOnSelection((table, startCell) => {\n          const generators = paste$1(SugarElement.fromDom(editor.getDoc()));\n          const targets = pasteRows(getCellsFromSelection(editor), startCell, clonedRows, generators);\n          execute(table, targets).each(postExecute);\n        });\n      });\n      const actOnType = getAction => (_ui, args) => get$c(args, 'type').each(type => {\n        actOnSelection(getAction(type), args.no_events);\n      });\n      each$1({\n        mceTableSplitCells: () => actOnSelection(actions.unmergeCells),\n        mceTableMergeCells: () => actOnSelection(actions.mergeCells),\n        mceTableInsertRowBefore: () => actOnSelection(actions.insertRowsBefore),\n        mceTableInsertRowAfter: () => actOnSelection(actions.insertRowsAfter),\n        mceTableInsertColBefore: () => actOnSelection(actions.insertColumnsBefore),\n        mceTableInsertColAfter: () => actOnSelection(actions.insertColumnsAfter),\n        mceTableDeleteCol: () => actOnSelection(actions.deleteColumn),\n        mceTableDeleteRow: () => actOnSelection(actions.deleteRow),\n        mceTableCutCol: () => copyColSelection().each(selection => {\n          setColumns(selection);\n          actOnSelection(actions.deleteColumn);\n        }),\n        mceTableCutRow: () => copyRowSelection().each(selection => {\n          setRows(selection);\n          actOnSelection(actions.deleteRow);\n        }),\n        mceTableCopyCol: () => copyColSelection().each(selection => setColumns(selection)),\n        mceTableCopyRow: () => copyRowSelection().each(selection => setRows(selection)),\n        mceTablePasteColBefore: () => pasteOnSelection(actions.pasteColsBefore, getColumns),\n        mceTablePasteColAfter: () => pasteOnSelection(actions.pasteColsAfter, getColumns),\n        mceTablePasteRowBefore: () => pasteOnSelection(actions.pasteRowsBefore, getRows),\n        mceTablePasteRowAfter: () => pasteOnSelection(actions.pasteRowsAfter, getRows),\n        mceTableDelete: eraseTable,\n        mceTableCellToggleClass: toggleTableCellClass,\n        mceTableToggleClass: toggleTableClass,\n        mceTableToggleCaption: toggleCaption,\n        mceTableSizingMode: (_ui, sizing) => setSizingMode(sizing),\n        mceTableCellType: actOnType(type => type === 'th' ? actions.makeCellsHeader : actions.unmakeCellsHeader),\n        mceTableColType: actOnType(type => type === 'th' ? actions.makeColumnsHeader : actions.unmakeColumnsHeader),\n        mceTableRowType: actOnType(type => {\n          switch (type) {\n          case 'header':\n            return actions.makeRowsHeader;\n          case 'footer':\n            return actions.makeRowsFooter;\n          default:\n            return actions.makeRowsBody;\n          }\n        })\n      }, (func, name) => editor.addCommand(name, func));\n      editor.addCommand('mceInsertTable', (_ui, args) => {\n        insertTable(editor, args.rows, args.columns, args.options);\n      });\n      editor.addCommand('mceTableApplyCellStyle', (_ui, args) => {\n        const getFormatName = style => 'tablecell' + style.toLowerCase().replace('-', '');\n        if (!isObject(args)) {\n          return;\n        }\n        const cells = getCellsFromSelection(editor);\n        if (cells.length === 0) {\n          return;\n        }\n        const validArgs = filter$1(args, (value, style) => editor.formatter.has(getFormatName(style)) && isString(value));\n        if (isEmpty(validArgs)) {\n          return;\n        }\n        each$1(validArgs, (value, style) => {\n          const formatName = getFormatName(style);\n          each$2(cells, cell => {\n            if (value === '') {\n              editor.formatter.remove(formatName, { value: null }, cell.dom, true);\n            } else {\n              editor.formatter.apply(formatName, { value }, cell.dom);\n            }\n          });\n        });\n        getTableFromCell(cells[0]).each(table => fireTableModified(editor, table.dom, styleModified));\n      });\n    };\n\n    const registerQueryCommands = (editor, actions) => {\n      const isRoot = getIsRoot(editor);\n      const lookupOnSelection = action => getSelectionCell(getSelectionStart(editor)).bind(cell => table(cell, isRoot).map(table => {\n        const targets = forMenu(getCellsFromSelection(editor), table, cell);\n        return action(table, targets);\n      })).getOr('');\n      each$1({\n        mceTableRowType: () => lookupOnSelection(actions.getTableRowType),\n        mceTableCellType: () => lookupOnSelection(actions.getTableCellType),\n        mceTableColType: () => lookupOnSelection(actions.getTableColType)\n      }, (func, name) => editor.addQueryValueHandler(name, func));\n    };\n\n    const adt$4 = Adt.generate([\n      { before: ['element'] },\n      {\n        on: [\n          'element',\n          'offset'\n        ]\n      },\n      { after: ['element'] }\n    ]);\n    const cata$1 = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n    const getStart$1 = situ => situ.fold(identity, identity, identity);\n    const before$2 = adt$4.before;\n    const on = adt$4.on;\n    const after$3 = adt$4.after;\n    const Situ = {\n      before: before$2,\n      on,\n      after: after$3,\n      cata: cata$1,\n      getStart: getStart$1\n    };\n\n    const create$4 = (selection, kill) => ({\n      selection,\n      kill\n    });\n    const Response = { create: create$4 };\n\n    const selectNode = (win, element) => {\n      const rng = win.document.createRange();\n      rng.selectNode(element.dom);\n      return rng;\n    };\n    const selectNodeContents = (win, element) => {\n      const rng = win.document.createRange();\n      selectNodeContentsUsing(rng, element);\n      return rng;\n    };\n    const selectNodeContentsUsing = (rng, element) => rng.selectNodeContents(element.dom);\n    const setStart = (rng, situ) => {\n      situ.fold(e => {\n        rng.setStartBefore(e.dom);\n      }, (e, o) => {\n        rng.setStart(e.dom, o);\n      }, e => {\n        rng.setStartAfter(e.dom);\n      });\n    };\n    const setFinish = (rng, situ) => {\n      situ.fold(e => {\n        rng.setEndBefore(e.dom);\n      }, (e, o) => {\n        rng.setEnd(e.dom, o);\n      }, e => {\n        rng.setEndAfter(e.dom);\n      });\n    };\n    const relativeToNative = (win, startSitu, finishSitu) => {\n      const range = win.document.createRange();\n      setStart(range, startSitu);\n      setFinish(range, finishSitu);\n      return range;\n    };\n    const exactToNative = (win, start, soffset, finish, foffset) => {\n      const rng = win.document.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n    const toRect = rect => ({\n      left: rect.left,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      width: rect.width,\n      height: rect.height\n    });\n    const getFirstRect$1 = rng => {\n      const rects = rng.getClientRects();\n      const rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();\n      return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();\n    };\n\n    const adt$3 = Adt.generate([\n      {\n        ltr: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      },\n      {\n        rtl: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n    const getRanges = (win, selection) => selection.match({\n      domRange: rng => {\n        return {\n          ltr: constant(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: (startSitu, finishSitu) => {\n        return {\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n        };\n      },\n      exact: (start, soffset, finish, foffset) => {\n        return {\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n        };\n      }\n    });\n    const doDiagnose = (win, ranges) => {\n      const rng = ranges.ltr();\n      if (rng.collapsed) {\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n      } else {\n        return fromRange(win, adt$3.ltr, rng);\n      }\n    };\n    const diagnose = (win, selection) => {\n      const ranges = getRanges(win, selection);\n      return doDiagnose(win, ranges);\n    };\n    const asLtrRange = (win, selection) => {\n      const diagnosis = diagnose(win, selection);\n      return diagnosis.match({\n        ltr: (start, soffset, finish, foffset) => {\n          const rng = win.document.createRange();\n          rng.setStart(start.dom, soffset);\n          rng.setEnd(finish.dom, foffset);\n          return rng;\n        },\n        rtl: (start, soffset, finish, foffset) => {\n          const rng = win.document.createRange();\n          rng.setStart(finish.dom, foffset);\n          rng.setEnd(start.dom, soffset);\n          return rng;\n        }\n      });\n    };\n    adt$3.ltr;\n    adt$3.rtl;\n\n    const create$3 = (start, soffset, finish, foffset) => ({\n      start,\n      soffset,\n      finish,\n      foffset\n    });\n    const SimRange = { create: create$3 };\n\n    const create$2 = (start, soffset, finish, foffset) => {\n      return {\n        start: Situ.on(start, soffset),\n        finish: Situ.on(finish, foffset)\n      };\n    };\n    const Situs = { create: create$2 };\n\n    const convertToRange = (win, selection) => {\n      const rng = asLtrRange(win, selection);\n      return SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset);\n    };\n    const makeSitus = Situs.create;\n\n    const sync = (container, isRoot, start, soffset, finish, foffset, selectRange) => {\n      if (!(eq$1(start, finish) && soffset === foffset)) {\n        return closest$1(start, 'td,th', isRoot).bind(s => {\n          return closest$1(finish, 'td,th', isRoot).bind(f => {\n            return detect(container, isRoot, s, f, selectRange);\n          });\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const detect = (container, isRoot, start, finish, selectRange) => {\n      if (!eq$1(start, finish)) {\n        return identify(start, finish, isRoot).bind(cellSel => {\n          const boxes = cellSel.boxes.getOr([]);\n          if (boxes.length > 1) {\n            selectRange(container, boxes, cellSel.start, cellSel.finish);\n            return Optional.some(Response.create(Optional.some(makeSitus(start, 0, start, getEnd(start))), true));\n          } else {\n            return Optional.none();\n          }\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const update = (rows, columns, container, selected, annotations) => {\n      const updateSelection = newSels => {\n        annotations.clearBeforeUpdate(container);\n        annotations.selectRange(container, newSels.boxes, newSels.start, newSels.finish);\n        return newSels.boxes;\n      };\n      return shiftSelection(selected, rows, columns, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map(updateSelection);\n    };\n\n    const traverse = (item, mode) => ({\n      item,\n      mode\n    });\n    const backtrack = (universe, item, _direction, transition = sidestep) => {\n      return universe.property().parent(item).map(p => {\n        return traverse(p, transition);\n      });\n    };\n    const sidestep = (universe, item, direction, transition = advance) => {\n      return direction.sibling(universe, item).map(p => {\n        return traverse(p, transition);\n      });\n    };\n    const advance = (universe, item, direction, transition = advance) => {\n      const children = universe.property().children(item);\n      const result = direction.first(children);\n      return result.map(r => {\n        return traverse(r, transition);\n      });\n    };\n    const successors = [\n      {\n        current: backtrack,\n        next: sidestep,\n        fallback: Optional.none()\n      },\n      {\n        current: sidestep,\n        next: advance,\n        fallback: Optional.some(backtrack)\n      },\n      {\n        current: advance,\n        next: advance,\n        fallback: Optional.some(sidestep)\n      }\n    ];\n    const go = (universe, item, mode, direction, rules = successors) => {\n      const ruleOpt = find$1(rules, succ => {\n        return succ.current === mode;\n      });\n      return ruleOpt.bind(rule => {\n        return rule.current(universe, item, direction, rule.next).orThunk(() => {\n          return rule.fallback.bind(fb => {\n            return go(universe, item, fb, direction);\n          });\n        });\n      });\n    };\n\n    const left$1 = () => {\n      const sibling = (universe, item) => {\n        return universe.query().prevSibling(item);\n      };\n      const first = children => {\n        return children.length > 0 ? Optional.some(children[children.length - 1]) : Optional.none();\n      };\n      return {\n        sibling,\n        first\n      };\n    };\n    const right$1 = () => {\n      const sibling = (universe, item) => {\n        return universe.query().nextSibling(item);\n      };\n      const first = children => {\n        return children.length > 0 ? Optional.some(children[0]) : Optional.none();\n      };\n      return {\n        sibling,\n        first\n      };\n    };\n    const Walkers = {\n      left: left$1,\n      right: right$1\n    };\n\n    const hone = (universe, item, predicate, mode, direction, isRoot) => {\n      const next = go(universe, item, mode, direction);\n      return next.bind(n => {\n        if (isRoot(n.item)) {\n          return Optional.none();\n        } else {\n          return predicate(n.item) ? Optional.some(n.item) : hone(universe, n.item, predicate, n.mode, direction, isRoot);\n        }\n      });\n    };\n    const left = (universe, item, predicate, isRoot) => {\n      return hone(universe, item, predicate, sidestep, Walkers.left(), isRoot);\n    };\n    const right = (universe, item, predicate, isRoot) => {\n      return hone(universe, item, predicate, sidestep, Walkers.right(), isRoot);\n    };\n\n    const isLeaf = universe => element => universe.property().children(element).length === 0;\n    const before$1 = (universe, item, isRoot) => {\n      return seekLeft$1(universe, item, isLeaf(universe), isRoot);\n    };\n    const after$2 = (universe, item, isRoot) => {\n      return seekRight$1(universe, item, isLeaf(universe), isRoot);\n    };\n    const seekLeft$1 = left;\n    const seekRight$1 = right;\n\n    const universe = DomUniverse();\n    const before = (element, isRoot) => {\n      return before$1(universe, element, isRoot);\n    };\n    const after$1 = (element, isRoot) => {\n      return after$2(universe, element, isRoot);\n    };\n    const seekLeft = (element, predicate, isRoot) => {\n      return seekLeft$1(universe, element, predicate, isRoot);\n    };\n    const seekRight = (element, predicate, isRoot) => {\n      return seekRight$1(universe, element, predicate, isRoot);\n    };\n\n    const ancestor = (scope, predicate, isRoot) => ancestor$2(scope, predicate, isRoot).isSome();\n\n    const adt$2 = Adt.generate([\n      { none: ['message'] },\n      { success: [] },\n      { failedUp: ['cell'] },\n      { failedDown: ['cell'] }\n    ]);\n    const isOverlapping = (bridge, before, after) => {\n      const beforeBounds = bridge.getRect(before);\n      const afterBounds = bridge.getRect(after);\n      return afterBounds.right > beforeBounds.left && afterBounds.left < beforeBounds.right;\n    };\n    const isRow = elem => {\n      return closest$1(elem, 'tr');\n    };\n    const verify = (bridge, before, beforeOffset, after, afterOffset, failure, isRoot) => {\n      return closest$1(after, 'td,th', isRoot).bind(afterCell => {\n        return closest$1(before, 'td,th', isRoot).map(beforeCell => {\n          if (!eq$1(afterCell, beforeCell)) {\n            return sharedOne(isRow, [\n              afterCell,\n              beforeCell\n            ]).fold(() => {\n              return isOverlapping(bridge, beforeCell, afterCell) ? adt$2.success() : failure(beforeCell);\n            }, _sharedRow => {\n              return failure(beforeCell);\n            });\n          } else {\n            return eq$1(after, afterCell) && getEnd(afterCell) === afterOffset ? failure(beforeCell) : adt$2.none('in same cell');\n          }\n        });\n      }).getOr(adt$2.none('default'));\n    };\n    const cata = (subject, onNone, onSuccess, onFailedUp, onFailedDown) => {\n      return subject.fold(onNone, onSuccess, onFailedUp, onFailedDown);\n    };\n    const BeforeAfter = {\n      ...adt$2,\n      verify,\n      cata\n    };\n\n    const inParent = (parent, children, element, index) => ({\n      parent,\n      children,\n      element,\n      index\n    });\n    const indexInParent = element => parent(element).bind(parent => {\n      const children = children$2(parent);\n      return indexOf(children, element).map(index => inParent(parent, children, element, index));\n    });\n    const indexOf = (elements, element) => findIndex(elements, curry(eq$1, element));\n\n    const isBr = isTag('br');\n    const gatherer = (cand, gather, isRoot) => {\n      return gather(cand, isRoot).bind(target => {\n        return isText(target) && get$6(target).trim().length === 0 ? gatherer(target, gather, isRoot) : Optional.some(target);\n      });\n    };\n    const handleBr = (isRoot, element, direction) => {\n      return direction.traverse(element).orThunk(() => {\n        return gatherer(element, direction.gather, isRoot);\n      }).map(direction.relative);\n    };\n    const findBr = (element, offset) => {\n      return child$2(element, offset).filter(isBr).orThunk(() => {\n        return child$2(element, offset - 1).filter(isBr);\n      });\n    };\n    const handleParent = (isRoot, element, offset, direction) => {\n      return findBr(element, offset).bind(br => {\n        return direction.traverse(br).fold(() => {\n          return gatherer(br, direction.gather, isRoot).map(direction.relative);\n        }, adjacent => {\n          return indexInParent(adjacent).map(info => {\n            return Situ.on(info.parent, info.index);\n          });\n        });\n      });\n    };\n    const tryBr = (isRoot, element, offset, direction) => {\n      const target = isBr(element) ? handleBr(isRoot, element, direction) : handleParent(isRoot, element, offset, direction);\n      return target.map(tgt => {\n        return {\n          start: tgt,\n          finish: tgt\n        };\n      });\n    };\n    const process = analysis => {\n      return BeforeAfter.cata(analysis, _message => {\n        return Optional.none();\n      }, () => {\n        return Optional.none();\n      }, cell => {\n        return Optional.some(point(cell, 0));\n      }, cell => {\n        return Optional.some(point(cell, getEnd(cell)));\n      });\n    };\n\n    const moveDown = (caret, amount) => {\n      return {\n        left: caret.left,\n        top: caret.top + amount,\n        right: caret.right,\n        bottom: caret.bottom + amount\n      };\n    };\n    const moveUp = (caret, amount) => {\n      return {\n        left: caret.left,\n        top: caret.top - amount,\n        right: caret.right,\n        bottom: caret.bottom - amount\n      };\n    };\n    const translate = (caret, xDelta, yDelta) => {\n      return {\n        left: caret.left + xDelta,\n        top: caret.top + yDelta,\n        right: caret.right + xDelta,\n        bottom: caret.bottom + yDelta\n      };\n    };\n    const getTop = caret => {\n      return caret.top;\n    };\n    const getBottom = caret => {\n      return caret.bottom;\n    };\n\n    const getPartialBox = (bridge, element, offset) => {\n      if (offset >= 0 && offset < getEnd(element)) {\n        return bridge.getRangedRect(element, offset, element, offset + 1);\n      } else if (offset > 0) {\n        return bridge.getRangedRect(element, offset - 1, element, offset);\n      }\n      return Optional.none();\n    };\n    const toCaret = rect => ({\n      left: rect.left,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom\n    });\n    const getElemBox = (bridge, element) => {\n      return Optional.some(bridge.getRect(element));\n    };\n    const getBoxAt = (bridge, element, offset) => {\n      if (isElement(element)) {\n        return getElemBox(bridge, element).map(toCaret);\n      } else if (isText(element)) {\n        return getPartialBox(bridge, element, offset).map(toCaret);\n      } else {\n        return Optional.none();\n      }\n    };\n    const getEntireBox = (bridge, element) => {\n      if (isElement(element)) {\n        return getElemBox(bridge, element).map(toCaret);\n      } else if (isText(element)) {\n        return bridge.getRangedRect(element, 0, element, getEnd(element)).map(toCaret);\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const JUMP_SIZE = 5;\n    const NUM_RETRIES = 100;\n    const adt$1 = Adt.generate([\n      { none: [] },\n      { retry: ['caret'] }\n    ]);\n    const isOutside = (caret, box) => {\n      return caret.left < box.left || Math.abs(box.right - caret.left) < 1 || caret.left > box.right;\n    };\n    const inOutsideBlock = (bridge, element, caret) => {\n      return closest$2(element, isBlock).fold(never, cell => {\n        return getEntireBox(bridge, cell).exists(box => {\n          return isOutside(caret, box);\n        });\n      });\n    };\n    const adjustDown = (bridge, element, guessBox, original, caret) => {\n      const lowerCaret = moveDown(caret, JUMP_SIZE);\n      if (Math.abs(guessBox.bottom - original.bottom) < 1) {\n        return adt$1.retry(lowerCaret);\n      } else if (guessBox.top > caret.bottom) {\n        return adt$1.retry(lowerCaret);\n      } else if (guessBox.top === caret.bottom) {\n        return adt$1.retry(moveDown(caret, 1));\n      } else {\n        return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate(lowerCaret, JUMP_SIZE, 0)) : adt$1.none();\n      }\n    };\n    const adjustUp = (bridge, element, guessBox, original, caret) => {\n      const higherCaret = moveUp(caret, JUMP_SIZE);\n      if (Math.abs(guessBox.top - original.top) < 1) {\n        return adt$1.retry(higherCaret);\n      } else if (guessBox.bottom < caret.top) {\n        return adt$1.retry(higherCaret);\n      } else if (guessBox.bottom === caret.top) {\n        return adt$1.retry(moveUp(caret, 1));\n      } else {\n        return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate(higherCaret, JUMP_SIZE, 0)) : adt$1.none();\n      }\n    };\n    const upMovement = {\n      point: getTop,\n      adjuster: adjustUp,\n      move: moveUp,\n      gather: before\n    };\n    const downMovement = {\n      point: getBottom,\n      adjuster: adjustDown,\n      move: moveDown,\n      gather: after$1\n    };\n    const isAtTable = (bridge, x, y) => {\n      return bridge.elementFromPoint(x, y).filter(elm => {\n        return name(elm) === 'table';\n      }).isSome();\n    };\n    const adjustForTable = (bridge, movement, original, caret, numRetries) => {\n      return adjustTil(bridge, movement, original, movement.move(caret, JUMP_SIZE), numRetries);\n    };\n    const adjustTil = (bridge, movement, original, caret, numRetries) => {\n      if (numRetries === 0) {\n        return Optional.some(caret);\n      }\n      if (isAtTable(bridge, caret.left, movement.point(caret))) {\n        return adjustForTable(bridge, movement, original, caret, numRetries - 1);\n      }\n      return bridge.situsFromPoint(caret.left, movement.point(caret)).bind(guess => {\n        return guess.start.fold(Optional.none, element => {\n          return getEntireBox(bridge, element).bind(guessBox => {\n            return movement.adjuster(bridge, element, guessBox, original, caret).fold(Optional.none, newCaret => {\n              return adjustTil(bridge, movement, original, newCaret, numRetries - 1);\n            });\n          }).orThunk(() => {\n            return Optional.some(caret);\n          });\n        }, Optional.none);\n      });\n    };\n    const checkScroll = (movement, adjusted, bridge) => {\n      if (movement.point(adjusted) > bridge.getInnerHeight()) {\n        return Optional.some(movement.point(adjusted) - bridge.getInnerHeight());\n      } else if (movement.point(adjusted) < 0) {\n        return Optional.some(-movement.point(adjusted));\n      } else {\n        return Optional.none();\n      }\n    };\n    const retry = (movement, bridge, caret) => {\n      const moved = movement.move(caret, JUMP_SIZE);\n      const adjusted = adjustTil(bridge, movement, caret, moved, NUM_RETRIES).getOr(moved);\n      return checkScroll(movement, adjusted, bridge).fold(() => {\n        return bridge.situsFromPoint(adjusted.left, movement.point(adjusted));\n      }, delta => {\n        bridge.scrollBy(0, delta);\n        return bridge.situsFromPoint(adjusted.left, movement.point(adjusted) - delta);\n      });\n    };\n    const Retries = {\n      tryUp: curry(retry, upMovement),\n      tryDown: curry(retry, downMovement),\n      getJumpSize: constant(JUMP_SIZE)\n    };\n\n    const MAX_RETRIES = 20;\n    const findSpot = (bridge, isRoot, direction) => {\n      return bridge.getSelection().bind(sel => {\n        return tryBr(isRoot, sel.finish, sel.foffset, direction).fold(() => {\n          return Optional.some(point(sel.finish, sel.foffset));\n        }, brNeighbour => {\n          const range = bridge.fromSitus(brNeighbour);\n          const analysis = BeforeAfter.verify(bridge, sel.finish, sel.foffset, range.finish, range.foffset, direction.failure, isRoot);\n          return process(analysis);\n        });\n      });\n    };\n    const scan = (bridge, isRoot, element, offset, direction, numRetries) => {\n      if (numRetries === 0) {\n        return Optional.none();\n      }\n      return tryCursor(bridge, isRoot, element, offset, direction).bind(situs => {\n        const range = bridge.fromSitus(situs);\n        const analysis = BeforeAfter.verify(bridge, element, offset, range.finish, range.foffset, direction.failure, isRoot);\n        return BeforeAfter.cata(analysis, () => {\n          return Optional.none();\n        }, () => {\n          return Optional.some(situs);\n        }, cell => {\n          if (eq$1(element, cell) && offset === 0) {\n            return tryAgain(bridge, element, offset, moveUp, direction);\n          } else {\n            return scan(bridge, isRoot, cell, 0, direction, numRetries - 1);\n          }\n        }, cell => {\n          if (eq$1(element, cell) && offset === getEnd(cell)) {\n            return tryAgain(bridge, element, offset, moveDown, direction);\n          } else {\n            return scan(bridge, isRoot, cell, getEnd(cell), direction, numRetries - 1);\n          }\n        });\n      });\n    };\n    const tryAgain = (bridge, element, offset, move, direction) => {\n      return getBoxAt(bridge, element, offset).bind(box => {\n        return tryAt(bridge, direction, move(box, Retries.getJumpSize()));\n      });\n    };\n    const tryAt = (bridge, direction, box) => {\n      const browser = detect$2().browser;\n      if (browser.isChromium() || browser.isSafari() || browser.isFirefox()) {\n        return direction.retry(bridge, box);\n      } else {\n        return Optional.none();\n      }\n    };\n    const tryCursor = (bridge, isRoot, element, offset, direction) => {\n      return getBoxAt(bridge, element, offset).bind(box => {\n        return tryAt(bridge, direction, box);\n      });\n    };\n    const handle$1 = (bridge, isRoot, direction) => {\n      return findSpot(bridge, isRoot, direction).bind(spot => {\n        return scan(bridge, isRoot, spot.element, spot.offset, direction, MAX_RETRIES).map(bridge.fromSitus);\n      });\n    };\n\n    const inSameTable = (elem, table) => {\n      return ancestor(elem, e => {\n        return parent(e).exists(p => {\n          return eq$1(p, table);\n        });\n      });\n    };\n    const simulate = (bridge, isRoot, direction, initial, anchor) => {\n      return closest$1(initial, 'td,th', isRoot).bind(start => {\n        return closest$1(start, 'table', isRoot).bind(table => {\n          if (!inSameTable(anchor, table)) {\n            return Optional.none();\n          }\n          return handle$1(bridge, isRoot, direction).bind(range => {\n            return closest$1(range.finish, 'td,th', isRoot).map(finish => {\n              return {\n                start,\n                finish,\n                range\n              };\n            });\n          });\n        });\n      });\n    };\n    const navigate = (bridge, isRoot, direction, initial, anchor, precheck) => {\n      return precheck(initial, isRoot).orThunk(() => {\n        return simulate(bridge, isRoot, direction, initial, anchor).map(info => {\n          const range = info.range;\n          return Response.create(Optional.some(makeSitus(range.start, range.soffset, range.finish, range.foffset)), true);\n        });\n      });\n    };\n    const firstUpCheck = (initial, isRoot) => {\n      return closest$1(initial, 'tr', isRoot).bind(startRow => {\n        return closest$1(startRow, 'table', isRoot).bind(table => {\n          const rows = descendants(table, 'tr');\n          if (eq$1(startRow, rows[0])) {\n            return seekLeft(table, element => {\n              return last$1(element).isSome();\n            }, isRoot).map(last => {\n              const lastOffset = getEnd(last);\n              return Response.create(Optional.some(makeSitus(last, lastOffset, last, lastOffset)), true);\n            });\n          } else {\n            return Optional.none();\n          }\n        });\n      });\n    };\n    const lastDownCheck = (initial, isRoot) => {\n      return closest$1(initial, 'tr', isRoot).bind(startRow => {\n        return closest$1(startRow, 'table', isRoot).bind(table => {\n          const rows = descendants(table, 'tr');\n          if (eq$1(startRow, rows[rows.length - 1])) {\n            return seekRight(table, element => {\n              return first(element).isSome();\n            }, isRoot).map(first => {\n              return Response.create(Optional.some(makeSitus(first, 0, first, 0)), true);\n            });\n          } else {\n            return Optional.none();\n          }\n        });\n      });\n    };\n    const select = (bridge, container, isRoot, direction, initial, anchor, selectRange) => {\n      return simulate(bridge, isRoot, direction, initial, anchor).bind(info => {\n        return detect(container, isRoot, info.start, info.finish, selectRange);\n      });\n    };\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const findCell = (target, isRoot) => closest$1(target, 'td,th', isRoot);\n    const MouseSelection = (bridge, container, isRoot, annotations) => {\n      const cursor = value();\n      const clearstate = cursor.clear;\n      const applySelection = event => {\n        cursor.on(start => {\n          annotations.clearBeforeUpdate(container);\n          findCell(event.target, isRoot).each(finish => {\n            identify(start, finish, isRoot).each(cellSel => {\n              const boxes = cellSel.boxes.getOr([]);\n              if (boxes.length === 1) {\n                const singleCell = boxes[0];\n                const isNonEditableCell = getRaw(singleCell) === 'false';\n                const isCellClosestContentEditable = is(closest(event.target), singleCell, eq$1);\n                if (isNonEditableCell && isCellClosestContentEditable) {\n                  annotations.selectRange(container, boxes, singleCell, singleCell);\n                  bridge.selectContents(singleCell);\n                }\n              } else if (boxes.length > 1) {\n                annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);\n                bridge.selectContents(finish);\n              }\n            });\n          });\n        });\n      };\n      const mousedown = event => {\n        annotations.clear(container);\n        findCell(event.target, isRoot).each(cursor.set);\n      };\n      const mouseover = event => {\n        applySelection(event);\n      };\n      const mouseup = event => {\n        applySelection(event);\n        clearstate();\n      };\n      return {\n        clearstate,\n        mousedown,\n        mouseover,\n        mouseup\n      };\n    };\n\n    const down = {\n      traverse: nextSibling,\n      gather: after$1,\n      relative: Situ.before,\n      retry: Retries.tryDown,\n      failure: BeforeAfter.failedDown\n    };\n    const up = {\n      traverse: prevSibling,\n      gather: before,\n      relative: Situ.before,\n      retry: Retries.tryUp,\n      failure: BeforeAfter.failedUp\n    };\n\n    const isKey = key => {\n      return keycode => {\n        return keycode === key;\n      };\n    };\n    const isUp = isKey(38);\n    const isDown = isKey(40);\n    const isNavigation = keycode => {\n      return keycode >= 37 && keycode <= 40;\n    };\n    const ltr = {\n      isBackward: isKey(37),\n      isForward: isKey(39)\n    };\n    const rtl = {\n      isBackward: isKey(39),\n      isForward: isKey(37)\n    };\n\n    const get$3 = _DOC => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n      return SugarPosition(x, y);\n    };\n    const by = (x, y, _DOC) => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const win = doc.defaultView;\n      if (win) {\n        win.scrollBy(x, y);\n      }\n    };\n\n    const adt = Adt.generate([\n      { domRange: ['rng'] },\n      {\n        relative: [\n          'startSitu',\n          'finishSitu'\n        ]\n      },\n      {\n        exact: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const exactFromRange = simRange => adt.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n    const getStart = selection => selection.match({\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n      exact: (start, _soffset, _finish, _foffset) => start\n    });\n    const domRange = adt.domRange;\n    const relative = adt.relative;\n    const exact = adt.exact;\n    const getWin = selection => {\n      const start = getStart(selection);\n      return defaultView(start);\n    };\n    const range = SimRange.create;\n    const SimSelection = {\n      domRange,\n      relative,\n      exact,\n      exactFromRange,\n      getWin,\n      range\n    };\n\n    const caretPositionFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\n        if (pos.offsetNode === null) {\n          return Optional.none();\n        }\n        const r = doc.dom.createRange();\n        r.setStart(pos.offsetNode, pos.offset);\n        r.collapse();\n        return Optional.some(r);\n      });\n    };\n    const caretRangeFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\n    };\n    const availableSearch = (() => {\n      if (document.caretPositionFromPoint) {\n        return caretPositionFromPoint;\n      } else if (document.caretRangeFromPoint) {\n        return caretRangeFromPoint;\n      } else {\n        return Optional.none;\n      }\n    })();\n    const fromPoint = (win, x, y) => {\n      const doc = SugarElement.fromDom(win.document);\n      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n    };\n\n    const beforeSpecial = (element, offset) => {\n      const name$1 = name(element);\n      if ('input' === name$1) {\n        return Situ.after(element);\n      } else if (!contains$2([\n          'br',\n          'img'\n        ], name$1)) {\n        return Situ.on(element, offset);\n      } else {\n        return offset === 0 ? Situ.before(element) : Situ.after(element);\n      }\n    };\n    const preprocessRelative = (startSitu, finishSitu) => {\n      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      return SimSelection.relative(start, finish);\n    };\n    const preprocessExact = (start, soffset, finish, foffset) => {\n      const startSitu = beforeSpecial(start, soffset);\n      const finishSitu = beforeSpecial(finish, foffset);\n      return SimSelection.relative(startSitu, finishSitu);\n    };\n\n    const makeRange = (start, soffset, finish, foffset) => {\n      const doc = owner(start);\n      const rng = doc.dom.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n    const after = (start, soffset, finish, foffset) => {\n      const r = makeRange(start, soffset, finish, foffset);\n      const same = eq$1(start, finish) && soffset === foffset;\n      return r.collapsed && !same;\n    };\n\n    const getNativeSelection = win => Optional.from(win.getSelection());\n    const doSetNativeRange = (win, rng) => {\n      getNativeSelection(win).each(selection => {\n        selection.removeAllRanges();\n        selection.addRange(rng);\n      });\n    };\n    const doSetRange = (win, start, soffset, finish, foffset) => {\n      const rng = exactToNative(win, start, soffset, finish, foffset);\n      doSetNativeRange(win, rng);\n    };\n    const setLegacyRtlRange = (win, selection, start, soffset, finish, foffset) => {\n      selection.collapse(start.dom, soffset);\n      selection.extend(finish.dom, foffset);\n    };\n    const setRangeFromRelative = (win, relative) => diagnose(win, relative).match({\n      ltr: (start, soffset, finish, foffset) => {\n        doSetRange(win, start, soffset, finish, foffset);\n      },\n      rtl: (start, soffset, finish, foffset) => {\n        getNativeSelection(win).each(selection => {\n          if (selection.setBaseAndExtent) {\n            selection.setBaseAndExtent(start.dom, soffset, finish.dom, foffset);\n          } else if (selection.extend) {\n            try {\n              setLegacyRtlRange(win, selection, start, soffset, finish, foffset);\n            } catch (e) {\n              doSetRange(win, finish, foffset, start, soffset);\n            }\n          } else {\n            doSetRange(win, finish, foffset, start, soffset);\n          }\n        });\n      }\n    });\n    const setExact = (win, start, soffset, finish, foffset) => {\n      const relative = preprocessExact(start, soffset, finish, foffset);\n      setRangeFromRelative(win, relative);\n    };\n    const setRelative = (win, startSitu, finishSitu) => {\n      const relative = preprocessRelative(startSitu, finishSitu);\n      setRangeFromRelative(win, relative);\n    };\n    const readRange = selection => {\n      if (selection.rangeCount > 0) {\n        const firstRng = selection.getRangeAt(0);\n        const lastRng = selection.getRangeAt(selection.rangeCount - 1);\n        return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));\n      } else {\n        return Optional.none();\n      }\n    };\n    const doGetExact = selection => {\n      if (selection.anchorNode === null || selection.focusNode === null) {\n        return readRange(selection);\n      } else {\n        const anchor = SugarElement.fromDom(selection.anchorNode);\n        const focus = SugarElement.fromDom(selection.focusNode);\n        return after(anchor, selection.anchorOffset, focus, selection.focusOffset) ? Optional.some(SimRange.create(anchor, selection.anchorOffset, focus, selection.focusOffset)) : readRange(selection);\n      }\n    };\n    const setToElement = (win, element, selectNodeContents$1 = true) => {\n      const rngGetter = selectNodeContents$1 ? selectNodeContents : selectNode;\n      const rng = rngGetter(win, element);\n      doSetNativeRange(win, rng);\n    };\n    const getExact = win => getNativeSelection(win).filter(sel => sel.rangeCount > 0).bind(doGetExact);\n    const get$2 = win => getExact(win).map(range => SimSelection.exact(range.start, range.soffset, range.finish, range.foffset));\n    const getFirstRect = (win, selection) => {\n      const rng = asLtrRange(win, selection);\n      return getFirstRect$1(rng);\n    };\n    const getAtPoint = (win, x, y) => fromPoint(win, x, y);\n    const clear = win => {\n      getNativeSelection(win).each(selection => selection.removeAllRanges());\n    };\n\n    const WindowBridge = win => {\n      const elementFromPoint = (x, y) => {\n        return SugarElement.fromPoint(SugarElement.fromDom(win.document), x, y);\n      };\n      const getRect = element => {\n        return element.dom.getBoundingClientRect();\n      };\n      const getRangedRect = (start, soffset, finish, foffset) => {\n        const sel = SimSelection.exact(start, soffset, finish, foffset);\n        return getFirstRect(win, sel);\n      };\n      const getSelection = () => {\n        return get$2(win).map(exactAdt => {\n          return convertToRange(win, exactAdt);\n        });\n      };\n      const fromSitus = situs => {\n        const relative = SimSelection.relative(situs.start, situs.finish);\n        return convertToRange(win, relative);\n      };\n      const situsFromPoint = (x, y) => {\n        return getAtPoint(win, x, y).map(exact => {\n          return Situs.create(exact.start, exact.soffset, exact.finish, exact.foffset);\n        });\n      };\n      const clearSelection = () => {\n        clear(win);\n      };\n      const collapseSelection = (toStart = false) => {\n        get$2(win).each(sel => sel.fold(rng => rng.collapse(toStart), (startSitu, finishSitu) => {\n          const situ = toStart ? startSitu : finishSitu;\n          setRelative(win, situ, situ);\n        }, (start, soffset, finish, foffset) => {\n          const node = toStart ? start : finish;\n          const offset = toStart ? soffset : foffset;\n          setExact(win, node, offset, node, offset);\n        }));\n      };\n      const selectNode = element => {\n        setToElement(win, element, false);\n      };\n      const selectContents = element => {\n        setToElement(win, element);\n      };\n      const setSelection = sel => {\n        setExact(win, sel.start, sel.soffset, sel.finish, sel.foffset);\n      };\n      const setRelativeSelection = (start, finish) => {\n        setRelative(win, start, finish);\n      };\n      const getInnerHeight = () => {\n        return win.innerHeight;\n      };\n      const getScrollY = () => {\n        const pos = get$3(SugarElement.fromDom(win.document));\n        return pos.top;\n      };\n      const scrollBy = (x, y) => {\n        by(x, y, SugarElement.fromDom(win.document));\n      };\n      return {\n        elementFromPoint,\n        getRect,\n        getRangedRect,\n        getSelection,\n        fromSitus,\n        situsFromPoint,\n        clearSelection,\n        collapseSelection,\n        setSelection,\n        setRelativeSelection,\n        selectNode,\n        selectContents,\n        getInnerHeight,\n        getScrollY,\n        scrollBy\n      };\n    };\n\n    const rc = (rows, cols) => ({\n      rows,\n      cols\n    });\n    const mouse = (win, container, isRoot, annotations) => {\n      const bridge = WindowBridge(win);\n      const handlers = MouseSelection(bridge, container, isRoot, annotations);\n      return {\n        clearstate: handlers.clearstate,\n        mousedown: handlers.mousedown,\n        mouseover: handlers.mouseover,\n        mouseup: handlers.mouseup\n      };\n    };\n    const keyboard = (win, container, isRoot, annotations) => {\n      const bridge = WindowBridge(win);\n      const clearToNavigate = () => {\n        annotations.clear(container);\n        return Optional.none();\n      };\n      const keydown = (event, start, soffset, finish, foffset, direction) => {\n        const realEvent = event.raw;\n        const keycode = realEvent.which;\n        const shiftKey = realEvent.shiftKey === true;\n        const handler = retrieve$1(container, annotations.selectedSelector).fold(() => {\n          if (isNavigation(keycode) && !shiftKey) {\n            annotations.clearBeforeUpdate(container);\n          }\n          if (isDown(keycode) && shiftKey) {\n            return curry(select, bridge, container, isRoot, down, finish, start, annotations.selectRange);\n          } else if (isUp(keycode) && shiftKey) {\n            return curry(select, bridge, container, isRoot, up, finish, start, annotations.selectRange);\n          } else if (isDown(keycode)) {\n            return curry(navigate, bridge, isRoot, down, finish, start, lastDownCheck);\n          } else if (isUp(keycode)) {\n            return curry(navigate, bridge, isRoot, up, finish, start, firstUpCheck);\n          } else {\n            return Optional.none;\n          }\n        }, selected => {\n          const update$1 = attempts => {\n            return () => {\n              const navigation = findMap(attempts, delta => {\n                return update(delta.rows, delta.cols, container, selected, annotations);\n              });\n              return navigation.fold(() => {\n                return getEdges(container, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map(edges => {\n                  const relative = isDown(keycode) || direction.isForward(keycode) ? Situ.after : Situ.before;\n                  bridge.setRelativeSelection(Situ.on(edges.first, 0), relative(edges.table));\n                  annotations.clear(container);\n                  return Response.create(Optional.none(), true);\n                });\n              }, _ => {\n                return Optional.some(Response.create(Optional.none(), true));\n              });\n            };\n          };\n          if (isDown(keycode) && shiftKey) {\n            return update$1([rc(+1, 0)]);\n          } else if (isUp(keycode) && shiftKey) {\n            return update$1([rc(-1, 0)]);\n          } else if (direction.isBackward(keycode) && shiftKey) {\n            return update$1([\n              rc(0, -1),\n              rc(-1, 0)\n            ]);\n          } else if (direction.isForward(keycode) && shiftKey) {\n            return update$1([\n              rc(0, +1),\n              rc(+1, 0)\n            ]);\n          } else if (isNavigation(keycode) && !shiftKey) {\n            return clearToNavigate;\n          } else {\n            return Optional.none;\n          }\n        });\n        return handler();\n      };\n      const keyup = (event, start, soffset, finish, foffset) => {\n        return retrieve$1(container, annotations.selectedSelector).fold(() => {\n          const realEvent = event.raw;\n          const keycode = realEvent.which;\n          const shiftKey = realEvent.shiftKey === true;\n          if (!shiftKey) {\n            return Optional.none();\n          }\n          if (isNavigation(keycode)) {\n            return sync(container, isRoot, start, soffset, finish, foffset, annotations.selectRange);\n          } else {\n            return Optional.none();\n          }\n        }, Optional.none);\n      };\n      return {\n        keydown,\n        keyup\n      };\n    };\n    const external = (win, container, isRoot, annotations) => {\n      const bridge = WindowBridge(win);\n      return (start, finish) => {\n        annotations.clearBeforeUpdate(container);\n        identify(start, finish, isRoot).each(cellSel => {\n          const boxes = cellSel.boxes.getOr([]);\n          annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);\n          bridge.selectContents(finish);\n          bridge.collapseSelection();\n        });\n      };\n    };\n\n    const read = (element, attr) => {\n      const value = get$b(element, attr);\n      return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$2 = (element, attr, id) => {\n      const old = read(element, attr);\n      const nu = old.concat([id]);\n      set$2(element, attr, nu.join(' '));\n      return true;\n    };\n    const remove$4 = (element, attr, id) => {\n      const nu = filter$2(read(element, attr), v => v !== id);\n      if (nu.length > 0) {\n        set$2(element, attr, nu.join(' '));\n      } else {\n        remove$7(element, attr);\n      }\n      return false;\n    };\n\n    const supports = element => element.dom.classList !== undefined;\n    const get$1 = element => read(element, 'class');\n    const add$1 = (element, clazz) => add$2(element, 'class', clazz);\n    const remove$3 = (element, clazz) => remove$4(element, 'class', clazz);\n\n    const add = (element, clazz) => {\n      if (supports(element)) {\n        element.dom.classList.add(clazz);\n      } else {\n        add$1(element, clazz);\n      }\n    };\n    const cleanClass = element => {\n      const classList = supports(element) ? element.dom.classList : get$1(element);\n      if (classList.length === 0) {\n        remove$7(element, 'class');\n      }\n    };\n    const remove$2 = (element, clazz) => {\n      if (supports(element)) {\n        const classList = element.dom.classList;\n        classList.remove(clazz);\n      } else {\n        remove$3(element, clazz);\n      }\n      cleanClass(element);\n    };\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const remove$1 = (element, classes) => {\n      each$2(classes, x => {\n        remove$2(element, x);\n      });\n    };\n\n    const addClass = clazz => element => {\n      add(element, clazz);\n    };\n    const removeClasses = classes => element => {\n      remove$1(element, classes);\n    };\n\n    const byClass = ephemera => {\n      const addSelectionClass = addClass(ephemera.selected);\n      const removeSelectionClasses = removeClasses([\n        ephemera.selected,\n        ephemera.lastSelected,\n        ephemera.firstSelected\n      ]);\n      const clear = container => {\n        const sels = descendants(container, ephemera.selectedSelector);\n        each$2(sels, removeSelectionClasses);\n      };\n      const selectRange = (container, cells, start, finish) => {\n        clear(container);\n        each$2(cells, addSelectionClass);\n        add(start, ephemera.firstSelected);\n        add(finish, ephemera.lastSelected);\n      };\n      return {\n        clearBeforeUpdate: clear,\n        clear,\n        selectRange,\n        selectedSelector: ephemera.selectedSelector,\n        firstSelectedSelector: ephemera.firstSelectedSelector,\n        lastSelectedSelector: ephemera.lastSelectedSelector\n      };\n    };\n    const byAttr = (ephemera, onSelection, onClear) => {\n      const removeSelectionAttributes = element => {\n        remove$7(element, ephemera.selected);\n        remove$7(element, ephemera.firstSelected);\n        remove$7(element, ephemera.lastSelected);\n      };\n      const addSelectionAttribute = element => {\n        set$2(element, ephemera.selected, '1');\n      };\n      const clear = container => {\n        clearBeforeUpdate(container);\n        onClear();\n      };\n      const clearBeforeUpdate = container => {\n        const sels = descendants(container, `${ ephemera.selectedSelector },${ ephemera.firstSelectedSelector },${ ephemera.lastSelectedSelector }`);\n        each$2(sels, removeSelectionAttributes);\n      };\n      const selectRange = (container, cells, start, finish) => {\n        clear(container);\n        each$2(cells, addSelectionAttribute);\n        set$2(start, ephemera.firstSelected, '1');\n        set$2(finish, ephemera.lastSelected, '1');\n        onSelection(cells, start, finish);\n      };\n      return {\n        clearBeforeUpdate,\n        clear,\n        selectRange,\n        selectedSelector: ephemera.selectedSelector,\n        firstSelectedSelector: ephemera.firstSelectedSelector,\n        lastSelectedSelector: ephemera.lastSelectedSelector\n      };\n    };\n    const SelectionAnnotation = {\n      byClass,\n      byAttr\n    };\n\n    const fold = (subject, onNone, onMultiple, onSingle) => {\n      switch (subject.tag) {\n      case 'none':\n        return onNone();\n      case 'single':\n        return onSingle(subject.element);\n      case 'multiple':\n        return onMultiple(subject.elements);\n      }\n    };\n    const none = () => ({ tag: 'none' });\n    const multiple = elements => ({\n      tag: 'multiple',\n      elements\n    });\n    const single = element => ({\n      tag: 'single',\n      element\n    });\n\n    const Selections = (lazyRoot, getStart, selectedSelector) => {\n      const get = () => retrieve(lazyRoot(), selectedSelector).fold(() => getStart().fold(none, single), multiple);\n      return { get };\n    };\n\n    const getUpOrLeftCells = (grid, selectedCells) => {\n      const upGrid = grid.slice(0, selectedCells[selectedCells.length - 1].row + 1);\n      const upDetails = toDetailList(upGrid);\n      return bind$2(upDetails, detail => {\n        const slicedCells = detail.cells.slice(0, selectedCells[selectedCells.length - 1].column + 1);\n        return map$1(slicedCells, cell => cell.element);\n      });\n    };\n    const getDownOrRightCells = (grid, selectedCells) => {\n      const downGrid = grid.slice(selectedCells[0].row + selectedCells[0].rowspan - 1, grid.length);\n      const downDetails = toDetailList(downGrid);\n      return bind$2(downDetails, detail => {\n        const slicedCells = detail.cells.slice(selectedCells[0].column + selectedCells[0].colspan - 1, detail.cells.length);\n        return map$1(slicedCells, cell => cell.element);\n      });\n    };\n    const getOtherCells = (table, target, generators) => {\n      const warehouse = Warehouse.fromTable(table);\n      const details = onCells(warehouse, target);\n      return details.map(selectedCells => {\n        const grid = toGrid(warehouse, generators, false);\n        const {rows} = extractGridDetails(grid);\n        const upOrLeftCells = getUpOrLeftCells(rows, selectedCells);\n        const downOrRightCells = getDownOrRightCells(rows, selectedCells);\n        return {\n          upOrLeftCells,\n          downOrRightCells\n        };\n      });\n    };\n\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n      target,\n      x,\n      y,\n      stop,\n      prevent,\n      kill,\n      raw\n    });\n    const fromRawEvent$1 = rawEvent => {\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n      const stop = () => rawEvent.stopPropagation();\n      const prevent = () => rawEvent.preventDefault();\n      const kill = compose(prevent, stop);\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n    };\n    const handle = (filter, handler) => rawEvent => {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent$1(rawEvent));\n      }\n    };\n    const binder = (element, event, filter, handler, useCapture) => {\n      const wrapped = handle(filter, handler);\n      element.dom.addEventListener(event, wrapped, useCapture);\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\n    };\n    const bind$1 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n    const unbind = (element, event, handler, useCapture) => {\n      element.dom.removeEventListener(event, handler, useCapture);\n    };\n\n    const filter = always;\n    const bind = (element, event, handler) => bind$1(element, event, filter, handler);\n    const fromRawEvent = fromRawEvent$1;\n\n    const hasInternalTarget = e => has(SugarElement.fromDom(e.target), 'ephox-snooker-resizer-bar') === false;\n    const TableCellSelectionHandler = (editor, resizeHandler) => {\n      const cellSelection = Selections(() => SugarElement.fromDom(editor.getBody()), () => getSelectionCell(getSelectionStart(editor), getIsRoot(editor)), ephemera.selectedSelector);\n      const onSelection = (cells, start, finish) => {\n        const tableOpt = table(start);\n        tableOpt.each(table => {\n          const cloneFormats = getTableCloneElements(editor);\n          const generators = cellOperations(noop, SugarElement.fromDom(editor.getDoc()), cloneFormats);\n          const selectedCells = getCellsFromSelection(editor);\n          const otherCells = getOtherCells(table, { selection: selectedCells }, generators);\n          fireTableSelectionChange(editor, cells, start, finish, otherCells);\n        });\n      };\n      const onClear = () => fireTableSelectionClear(editor);\n      const annotations = SelectionAnnotation.byAttr(ephemera, onSelection, onClear);\n      editor.on('init', _e => {\n        const win = editor.getWin();\n        const body = getBody(editor);\n        const isRoot = getIsRoot(editor);\n        const syncSelection = () => {\n          const sel = editor.selection;\n          const start = SugarElement.fromDom(sel.getStart());\n          const end = SugarElement.fromDom(sel.getEnd());\n          const shared = sharedOne(table, [\n            start,\n            end\n          ]);\n          shared.fold(() => annotations.clear(body), noop);\n        };\n        const mouseHandlers = mouse(win, body, isRoot, annotations);\n        const keyHandlers = keyboard(win, body, isRoot, annotations);\n        const external$1 = external(win, body, isRoot, annotations);\n        const hasShiftKey = event => event.raw.shiftKey === true;\n        editor.on('TableSelectorChange', e => external$1(e.start, e.finish));\n        const handleResponse = (event, response) => {\n          if (!hasShiftKey(event)) {\n            return;\n          }\n          if (response.kill) {\n            event.kill();\n          }\n          response.selection.each(ns => {\n            const relative = SimSelection.relative(ns.start, ns.finish);\n            const rng = asLtrRange(win, relative);\n            editor.selection.setRng(rng);\n          });\n        };\n        const keyup = event => {\n          const wrappedEvent = fromRawEvent(event);\n          if (wrappedEvent.raw.shiftKey && isNavigation(wrappedEvent.raw.which)) {\n            const rng = editor.selection.getRng();\n            const start = SugarElement.fromDom(rng.startContainer);\n            const end = SugarElement.fromDom(rng.endContainer);\n            keyHandlers.keyup(wrappedEvent, start, rng.startOffset, end, rng.endOffset).each(response => {\n              handleResponse(wrappedEvent, response);\n            });\n          }\n        };\n        const keydown = event => {\n          const wrappedEvent = fromRawEvent(event);\n          resizeHandler.hide();\n          const rng = editor.selection.getRng();\n          const start = SugarElement.fromDom(rng.startContainer);\n          const end = SugarElement.fromDom(rng.endContainer);\n          const direction = onDirection(ltr, rtl)(SugarElement.fromDom(editor.selection.getStart()));\n          keyHandlers.keydown(wrappedEvent, start, rng.startOffset, end, rng.endOffset, direction).each(response => {\n            handleResponse(wrappedEvent, response);\n          });\n          resizeHandler.show();\n        };\n        const isLeftMouse = raw => raw.button === 0;\n        const isLeftButtonPressed = raw => {\n          if (raw.buttons === undefined) {\n            return true;\n          }\n          return (raw.buttons & 1) !== 0;\n        };\n        const dragStart = _e => {\n          mouseHandlers.clearstate();\n        };\n        const mouseDown = e => {\n          if (isLeftMouse(e) && hasInternalTarget(e)) {\n            mouseHandlers.mousedown(fromRawEvent(e));\n          }\n        };\n        const mouseOver = e => {\n          if (isLeftButtonPressed(e) && hasInternalTarget(e)) {\n            mouseHandlers.mouseover(fromRawEvent(e));\n          }\n        };\n        const mouseUp = e => {\n          if (isLeftMouse(e) && hasInternalTarget(e)) {\n            mouseHandlers.mouseup(fromRawEvent(e));\n          }\n        };\n        const getDoubleTap = () => {\n          const lastTarget = Cell(SugarElement.fromDom(body));\n          const lastTimeStamp = Cell(0);\n          const touchEnd = t => {\n            const target = SugarElement.fromDom(t.target);\n            if (isTag('td')(target) || isTag('th')(target)) {\n              const lT = lastTarget.get();\n              const lTS = lastTimeStamp.get();\n              if (eq$1(lT, target) && t.timeStamp - lTS < 300) {\n                t.preventDefault();\n                external$1(target, target);\n              }\n            }\n            lastTarget.set(target);\n            lastTimeStamp.set(t.timeStamp);\n          };\n          return { touchEnd };\n        };\n        const doubleTap = getDoubleTap();\n        editor.on('dragstart', dragStart);\n        editor.on('mousedown', mouseDown);\n        editor.on('mouseover', mouseOver);\n        editor.on('mouseup', mouseUp);\n        editor.on('touchend', doubleTap.touchEnd);\n        editor.on('keyup', keyup);\n        editor.on('keydown', keydown);\n        editor.on('NodeChange', syncSelection);\n      });\n      editor.on('PreInit', () => {\n        editor.serializer.addTempAttr(ephemera.firstSelected);\n        editor.serializer.addTempAttr(ephemera.lastSelected);\n      });\n      const clearSelectedCells = container => annotations.clear(SugarElement.fromDom(container));\n      const getSelectedCells = () => fold(cellSelection.get(), constant([]), cells => {\n        return map$1(cells, cell => cell.dom);\n      }, cell => [cell.dom]);\n      return {\n        getSelectedCells,\n        clearSelectedCells\n      };\n    };\n\n    const Event = fields => {\n      let handlers = [];\n      const bind = handler => {\n        if (handler === undefined) {\n          throw new Error('Event bind error: undefined handler');\n        }\n        handlers.push(handler);\n      };\n      const unbind = handler => {\n        handlers = filter$2(handlers, h => {\n          return h !== handler;\n        });\n      };\n      const trigger = (...args) => {\n        const event = {};\n        each$2(fields, (name, i) => {\n          event[name] = args[i];\n        });\n        each$2(handlers, handler => {\n          handler(event);\n        });\n      };\n      return {\n        bind,\n        unbind,\n        trigger\n      };\n    };\n\n    const create$1 = typeDefs => {\n      const registry = map(typeDefs, event => {\n        return {\n          bind: event.bind,\n          unbind: event.unbind\n        };\n      });\n      const trigger = map(typeDefs, event => {\n        return event.trigger;\n      });\n      return {\n        registry,\n        trigger\n      };\n    };\n\n    const last = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        cancel();\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n\n    const sort = arr => {\n      return arr.slice(0).sort();\n    };\n    const reqMessage = (required, keys) => {\n      throw new Error('All required keys (' + sort(required).join(', ') + ') were not specified. Specified keys were: ' + sort(keys).join(', ') + '.');\n    };\n    const unsuppMessage = unsupported => {\n      throw new Error('Unsupported keys for object: ' + sort(unsupported).join(', '));\n    };\n    const validateStrArr = (label, array) => {\n      if (!isArray(array)) {\n        throw new Error('The ' + label + ' fields must be an array. Was: ' + array + '.');\n      }\n      each$2(array, a => {\n        if (!isString(a)) {\n          throw new Error('The value ' + a + ' in the ' + label + ' fields was not a string.');\n        }\n      });\n    };\n    const invalidTypeMessage = (incorrect, type) => {\n      throw new Error('All values need to be of type: ' + type + '. Keys (' + sort(incorrect).join(', ') + ') were not.');\n    };\n    const checkDupes = everything => {\n      const sorted = sort(everything);\n      const dupe = find$1(sorted, (s, i) => {\n        return i < sorted.length - 1 && s === sorted[i + 1];\n      });\n      dupe.each(d => {\n        throw new Error('The field: ' + d + ' occurs more than once in the combined fields: [' + sorted.join(', ') + '].');\n      });\n    };\n\n    const base = (handleUnsupported, required) => {\n      return baseWith(handleUnsupported, required, {\n        validate: isFunction,\n        label: 'function'\n      });\n    };\n    const baseWith = (handleUnsupported, required, pred) => {\n      if (required.length === 0) {\n        throw new Error('You must specify at least one required field.');\n      }\n      validateStrArr('required', required);\n      checkDupes(required);\n      return obj => {\n        const keys$1 = keys(obj);\n        const allReqd = forall(required, req => {\n          return contains$2(keys$1, req);\n        });\n        if (!allReqd) {\n          reqMessage(required, keys$1);\n        }\n        handleUnsupported(required, keys$1);\n        const invalidKeys = filter$2(required, key => {\n          return !pred.validate(obj[key], key);\n        });\n        if (invalidKeys.length > 0) {\n          invalidTypeMessage(invalidKeys, pred.label);\n        }\n        return obj;\n      };\n    };\n    const handleExact = (required, keys) => {\n      const unsupported = filter$2(keys, key => {\n        return !contains$2(required, key);\n      });\n      if (unsupported.length > 0) {\n        unsuppMessage(unsupported);\n      }\n    };\n    const exactly = required => base(handleExact, required);\n\n    const DragMode = exactly([\n      'compare',\n      'extract',\n      'mutate',\n      'sink'\n    ]);\n    const DragSink = exactly([\n      'element',\n      'start',\n      'stop',\n      'destroy'\n    ]);\n    const DragApi = exactly([\n      'forceDrop',\n      'drop',\n      'move',\n      'delayDrop'\n    ]);\n\n    const InDrag = () => {\n      let previous = Optional.none();\n      const reset = () => {\n        previous = Optional.none();\n      };\n      const update = (mode, nu) => {\n        const result = previous.map(old => {\n          return mode.compare(old, nu);\n        });\n        previous = Optional.some(nu);\n        return result;\n      };\n      const onEvent = (event, mode) => {\n        const dataOption = mode.extract(event);\n        dataOption.each(data => {\n          const offset = update(mode, data);\n          offset.each(d => {\n            events.trigger.move(d);\n          });\n        });\n      };\n      const events = create$1({ move: Event(['info']) });\n      return {\n        onEvent,\n        reset,\n        events: events.registry\n      };\n    };\n\n    const NoDrag = () => {\n      const events = create$1({ move: Event(['info']) });\n      return {\n        onEvent: noop,\n        reset: noop,\n        events: events.registry\n      };\n    };\n\n    const Movement = () => {\n      const noDragState = NoDrag();\n      const inDragState = InDrag();\n      let dragState = noDragState;\n      const on = () => {\n        dragState.reset();\n        dragState = inDragState;\n      };\n      const off = () => {\n        dragState.reset();\n        dragState = noDragState;\n      };\n      const onEvent = (event, mode) => {\n        dragState.onEvent(event, mode);\n      };\n      const isOn = () => {\n        return dragState === inDragState;\n      };\n      return {\n        on,\n        off,\n        isOn,\n        onEvent,\n        events: inDragState.events\n      };\n    };\n\n    const setup = (mutation, mode, settings) => {\n      let active = false;\n      const events = create$1({\n        start: Event([]),\n        stop: Event([])\n      });\n      const movement = Movement();\n      const drop = () => {\n        sink.stop();\n        if (movement.isOn()) {\n          movement.off();\n          events.trigger.stop();\n        }\n      };\n      const throttledDrop = last(drop, 200);\n      const go = parent => {\n        sink.start(parent);\n        movement.on();\n        events.trigger.start();\n      };\n      const mousemove = event => {\n        throttledDrop.cancel();\n        movement.onEvent(event, mode);\n      };\n      movement.events.move.bind(event => {\n        mode.mutate(mutation, event.info);\n      });\n      const on = () => {\n        active = true;\n      };\n      const off = () => {\n        active = false;\n      };\n      const runIfActive = f => {\n        return (...args) => {\n          if (active) {\n            f.apply(null, args);\n          }\n        };\n      };\n      const sink = mode.sink(DragApi({\n        forceDrop: drop,\n        drop: runIfActive(drop),\n        move: runIfActive(mousemove),\n        delayDrop: runIfActive(throttledDrop.throttle)\n      }), settings);\n      const destroy = () => {\n        sink.destroy();\n      };\n      return {\n        element: sink.element,\n        go,\n        on,\n        off,\n        destroy,\n        events: events.registry\n      };\n    };\n\n    const css = namespace => {\n      const dashNamespace = namespace.replace(/\\./g, '-');\n      const resolve = str => {\n        return dashNamespace + '-' + str;\n      };\n      return { resolve };\n    };\n\n    const styles$1 = css('ephox-dragster');\n    const resolve$1 = styles$1.resolve;\n\n    const Blocker = options => {\n      const settings = {\n        layerClass: resolve$1('blocker'),\n        ...options\n      };\n      const div = SugarElement.fromTag('div');\n      set$2(div, 'role', 'presentation');\n      setAll(div, {\n        position: 'fixed',\n        left: '0px',\n        top: '0px',\n        width: '100%',\n        height: '100%'\n      });\n      add(div, resolve$1('blocker'));\n      add(div, settings.layerClass);\n      const element = constant(div);\n      const destroy = () => {\n        remove$6(div);\n      };\n      return {\n        element,\n        destroy\n      };\n    };\n\n    const compare = (old, nu) => {\n      return SugarPosition(nu.left - old.left, nu.top - old.top);\n    };\n    const extract = event => {\n      return Optional.some(SugarPosition(event.x, event.y));\n    };\n    const mutate = (mutation, info) => {\n      mutation.mutate(info.left, info.top);\n    };\n    const sink = (dragApi, settings) => {\n      const blocker = Blocker(settings);\n      const mdown = bind(blocker.element(), 'mousedown', dragApi.forceDrop);\n      const mup = bind(blocker.element(), 'mouseup', dragApi.drop);\n      const mmove = bind(blocker.element(), 'mousemove', dragApi.move);\n      const mout = bind(blocker.element(), 'mouseout', dragApi.delayDrop);\n      const destroy = () => {\n        blocker.destroy();\n        mup.unbind();\n        mmove.unbind();\n        mout.unbind();\n        mdown.unbind();\n      };\n      const start = parent => {\n        append$1(parent, blocker.element());\n      };\n      const stop = () => {\n        remove$6(blocker.element());\n      };\n      return DragSink({\n        element: blocker.element,\n        start,\n        stop,\n        destroy\n      });\n    };\n    var MouseDrag = DragMode({\n      compare,\n      extract,\n      sink,\n      mutate\n    });\n\n    const transform = (mutation, settings = {}) => {\n      var _a;\n      const mode = (_a = settings.mode) !== null && _a !== void 0 ? _a : MouseDrag;\n      return setup(mutation, mode, settings);\n    };\n\n    const styles = css('ephox-snooker');\n    const resolve = styles.resolve;\n\n    const Mutation = () => {\n      const events = create$1({\n        drag: Event([\n          'xDelta',\n          'yDelta'\n        ])\n      });\n      const mutate = (x, y) => {\n        events.trigger.drag(x, y);\n      };\n      return {\n        mutate,\n        events: events.registry\n      };\n    };\n\n    const BarMutation = () => {\n      const events = create$1({\n        drag: Event([\n          'xDelta',\n          'yDelta',\n          'target'\n        ])\n      });\n      let target = Optional.none();\n      const delegate = Mutation();\n      delegate.events.drag.bind(event => {\n        target.each(t => {\n          events.trigger.drag(event.xDelta, event.yDelta, t);\n        });\n      });\n      const assign = t => {\n        target = Optional.some(t);\n      };\n      const get = () => {\n        return target;\n      };\n      return {\n        assign,\n        get,\n        mutate: delegate.mutate,\n        events: events.registry\n      };\n    };\n\n    const col = (column, x, y, w, h) => {\n      const bar = SugarElement.fromTag('div');\n      setAll(bar, {\n        position: 'absolute',\n        left: x - w / 2 + 'px',\n        top: y + 'px',\n        height: h + 'px',\n        width: w + 'px'\n      });\n      setAll$1(bar, {\n        'data-column': column,\n        'role': 'presentation'\n      });\n      return bar;\n    };\n    const row = (r, x, y, w, h) => {\n      const bar = SugarElement.fromTag('div');\n      setAll(bar, {\n        position: 'absolute',\n        left: x + 'px',\n        top: y - h / 2 + 'px',\n        height: h + 'px',\n        width: w + 'px'\n      });\n      setAll$1(bar, {\n        'data-row': r,\n        'role': 'presentation'\n      });\n      return bar;\n    };\n\n    const resizeBar = resolve('resizer-bar');\n    const resizeRowBar = resolve('resizer-rows');\n    const resizeColBar = resolve('resizer-cols');\n    const BAR_THICKNESS = 7;\n    const resizableRows = (warehouse, isResizable) => bind$2(warehouse.all, (row, i) => isResizable(row.element) ? [i] : []);\n    const resizableColumns = (warehouse, isResizable) => {\n      const resizableCols = [];\n      range$1(warehouse.grid.columns, index => {\n        const colElmOpt = Warehouse.getColumnAt(warehouse, index).map(col => col.element);\n        if (colElmOpt.forall(isResizable)) {\n          resizableCols.push(index);\n        }\n      });\n      return filter$2(resizableCols, colIndex => {\n        const columnCells = Warehouse.filterItems(warehouse, cell => cell.column === colIndex);\n        return forall(columnCells, cell => isResizable(cell.element));\n      });\n    };\n    const destroy = wire => {\n      const previous = descendants(wire.parent(), '.' + resizeBar);\n      each$2(previous, remove$6);\n    };\n    const drawBar = (wire, positions, create) => {\n      const origin = wire.origin();\n      each$2(positions, cpOption => {\n        cpOption.each(cp => {\n          const bar = create(origin, cp);\n          add(bar, resizeBar);\n          append$1(wire.parent(), bar);\n        });\n      });\n    };\n    const refreshCol = (wire, colPositions, position, tableHeight) => {\n      drawBar(wire, colPositions, (origin, cp) => {\n        const colBar = col(cp.col, cp.x - origin.left, position.top - origin.top, BAR_THICKNESS, tableHeight);\n        add(colBar, resizeColBar);\n        return colBar;\n      });\n    };\n    const refreshRow = (wire, rowPositions, position, tableWidth) => {\n      drawBar(wire, rowPositions, (origin, cp) => {\n        const rowBar = row(cp.row, position.left - origin.left, cp.y - origin.top, tableWidth, BAR_THICKNESS);\n        add(rowBar, resizeRowBar);\n        return rowBar;\n      });\n    };\n    const refreshGrid = (warhouse, wire, table, rows, cols) => {\n      const position = absolute(table);\n      const isResizable = wire.isResizable;\n      const rowPositions = rows.length > 0 ? height.positions(rows, table) : [];\n      const resizableRowBars = rowPositions.length > 0 ? resizableRows(warhouse, isResizable) : [];\n      const resizableRowPositions = filter$2(rowPositions, (_pos, i) => exists(resizableRowBars, barIndex => i === barIndex));\n      refreshRow(wire, resizableRowPositions, position, getOuter$2(table));\n      const colPositions = cols.length > 0 ? width.positions(cols, table) : [];\n      const resizableColBars = colPositions.length > 0 ? resizableColumns(warhouse, isResizable) : [];\n      const resizableColPositions = filter$2(colPositions, (_pos, i) => exists(resizableColBars, barIndex => i === barIndex));\n      refreshCol(wire, resizableColPositions, position, getOuter$1(table));\n    };\n    const refresh = (wire, table) => {\n      destroy(wire);\n      if (wire.isResizable(table)) {\n        const warehouse = Warehouse.fromTable(table);\n        const rows$1 = rows(warehouse);\n        const cols = columns(warehouse);\n        refreshGrid(warehouse, wire, table, rows$1, cols);\n      }\n    };\n    const each = (wire, f) => {\n      const bars = descendants(wire.parent(), '.' + resizeBar);\n      each$2(bars, f);\n    };\n    const hide = wire => {\n      each(wire, bar => {\n        set$1(bar, 'display', 'none');\n      });\n    };\n    const show = wire => {\n      each(wire, bar => {\n        set$1(bar, 'display', 'block');\n      });\n    };\n    const isRowBar = element => {\n      return has(element, resizeRowBar);\n    };\n    const isColBar = element => {\n      return has(element, resizeColBar);\n    };\n\n    const resizeBarDragging = resolve('resizer-bar-dragging');\n    const BarManager = wire => {\n      const mutation = BarMutation();\n      const resizing = transform(mutation, {});\n      let hoverTable = Optional.none();\n      const getResizer = (element, type) => {\n        return Optional.from(get$b(element, type));\n      };\n      mutation.events.drag.bind(event => {\n        getResizer(event.target, 'data-row').each(_dataRow => {\n          const currentRow = getCssValue(event.target, 'top');\n          set$1(event.target, 'top', currentRow + event.yDelta + 'px');\n        });\n        getResizer(event.target, 'data-column').each(_dataCol => {\n          const currentCol = getCssValue(event.target, 'left');\n          set$1(event.target, 'left', currentCol + event.xDelta + 'px');\n        });\n      });\n      const getDelta = (target, dir) => {\n        const newX = getCssValue(target, dir);\n        const oldX = getAttrValue(target, 'data-initial-' + dir, 0);\n        return newX - oldX;\n      };\n      resizing.events.stop.bind(() => {\n        mutation.get().each(target => {\n          hoverTable.each(table => {\n            getResizer(target, 'data-row').each(row => {\n              const delta = getDelta(target, 'top');\n              remove$7(target, 'data-initial-top');\n              events.trigger.adjustHeight(table, delta, parseInt(row, 10));\n            });\n            getResizer(target, 'data-column').each(column => {\n              const delta = getDelta(target, 'left');\n              remove$7(target, 'data-initial-left');\n              events.trigger.adjustWidth(table, delta, parseInt(column, 10));\n            });\n            refresh(wire, table);\n          });\n        });\n      });\n      const handler = (target, dir) => {\n        events.trigger.startAdjust();\n        mutation.assign(target);\n        set$2(target, 'data-initial-' + dir, getCssValue(target, dir));\n        add(target, resizeBarDragging);\n        set$1(target, 'opacity', '0.2');\n        resizing.go(wire.parent());\n      };\n      const mousedown = bind(wire.parent(), 'mousedown', event => {\n        if (isRowBar(event.target)) {\n          handler(event.target, 'top');\n        }\n        if (isColBar(event.target)) {\n          handler(event.target, 'left');\n        }\n      });\n      const isRoot = e => {\n        return eq$1(e, wire.view());\n      };\n      const findClosestEditableTable = target => closest$1(target, 'table', isRoot).filter(isEditable$1);\n      const mouseover = bind(wire.view(), 'mouseover', event => {\n        findClosestEditableTable(event.target).fold(() => {\n          if (inBody(event.target)) {\n            destroy(wire);\n          }\n        }, table => {\n          hoverTable = Optional.some(table);\n          refresh(wire, table);\n        });\n      });\n      const destroy$1 = () => {\n        mousedown.unbind();\n        mouseover.unbind();\n        resizing.destroy();\n        destroy(wire);\n      };\n      const refresh$1 = tbl => {\n        refresh(wire, tbl);\n      };\n      const events = create$1({\n        adjustHeight: Event([\n          'table',\n          'delta',\n          'row'\n        ]),\n        adjustWidth: Event([\n          'table',\n          'delta',\n          'column'\n        ]),\n        startAdjust: Event([])\n      });\n      return {\n        destroy: destroy$1,\n        refresh: refresh$1,\n        on: resizing.on,\n        off: resizing.off,\n        hideBars: curry(hide, wire),\n        showBars: curry(show, wire),\n        events: events.registry\n      };\n    };\n\n    const create = (wire, resizing, lazySizing) => {\n      const hdirection = height;\n      const vdirection = width;\n      const manager = BarManager(wire);\n      const events = create$1({\n        beforeResize: Event([\n          'table',\n          'type'\n        ]),\n        afterResize: Event([\n          'table',\n          'type'\n        ]),\n        startDrag: Event([])\n      });\n      manager.events.adjustHeight.bind(event => {\n        const table = event.table;\n        events.trigger.beforeResize(table, 'row');\n        const delta = hdirection.delta(event.delta, table);\n        adjustHeight(table, delta, event.row, hdirection);\n        events.trigger.afterResize(table, 'row');\n      });\n      manager.events.startAdjust.bind(_event => {\n        events.trigger.startDrag();\n      });\n      manager.events.adjustWidth.bind(event => {\n        const table = event.table;\n        events.trigger.beforeResize(table, 'col');\n        const delta = vdirection.delta(event.delta, table);\n        const tableSize = lazySizing(table);\n        adjustWidth(table, delta, event.column, resizing, tableSize);\n        events.trigger.afterResize(table, 'col');\n      });\n      return {\n        on: manager.on,\n        off: manager.off,\n        refreshBars: manager.refresh,\n        hideBars: manager.hideBars,\n        showBars: manager.showBars,\n        destroy: manager.destroy,\n        events: events.registry\n      };\n    };\n    const TableResize = { create };\n\n    const only = (element, isResizable) => {\n      const parent = isDocument(element) ? documentElement(element) : element;\n      return {\n        parent: constant(parent),\n        view: constant(element),\n        origin: constant(SugarPosition(0, 0)),\n        isResizable\n      };\n    };\n    const detached = (editable, chrome, isResizable) => {\n      const origin = () => absolute(chrome);\n      return {\n        parent: constant(chrome),\n        view: constant(editable),\n        origin,\n        isResizable\n      };\n    };\n    const body = (editable, chrome, isResizable) => {\n      return {\n        parent: constant(chrome),\n        view: constant(editable),\n        origin: constant(SugarPosition(0, 0)),\n        isResizable\n      };\n    };\n    const ResizeWire = {\n      only,\n      detached,\n      body\n    };\n\n    const createContainer = () => {\n      const container = SugarElement.fromTag('div');\n      setAll(container, {\n        position: 'static',\n        height: '0',\n        width: '0',\n        padding: '0',\n        margin: '0',\n        border: '0'\n      });\n      append$1(body$1(), container);\n      return container;\n    };\n    const get = (editor, isResizable) => {\n      return editor.inline ? ResizeWire.body(SugarElement.fromDom(editor.getBody()), createContainer(), isResizable) : ResizeWire.only(SugarElement.fromDom(editor.getDoc()), isResizable);\n    };\n    const remove = (editor, wire) => {\n      if (editor.inline) {\n        remove$6(wire.parent());\n      }\n    };\n\n    const isTable = node => isNonNullable(node) && node.tagName === 'TABLE';\n    const barResizerPrefix = 'bar-';\n    const isResizable = elm => get$b(elm, 'data-mce-resize') !== 'false';\n    const syncPixels = table => {\n      const warehouse = Warehouse.fromTable(table);\n      if (!Warehouse.hasColumns(warehouse)) {\n        each$2(cells$1(table), cell => {\n          const computedWidth = get$a(cell, 'width');\n          set$1(cell, 'width', computedWidth);\n          remove$7(cell, 'width');\n        });\n      }\n    };\n    const TableResizeHandler = editor => {\n      const selectionRng = value();\n      const tableResize = value();\n      const resizeWire = value();\n      let startW;\n      let startRawW;\n      const lazySizing = table => get$5(editor, table);\n      const lazyResizingBehaviour = () => isPreserveTableColumnResizing(editor) ? preserveTable() : resizeTable();\n      const getNumColumns = table => getGridSize(table).columns;\n      const afterCornerResize = (table, origin, width) => {\n        const isRightEdgeResize = endsWith(origin, 'e');\n        if (startRawW === '') {\n          convertToPercentSize(table);\n        }\n        if (width !== startW && startRawW !== '') {\n          set$1(table, 'width', startRawW);\n          const resizing = lazyResizingBehaviour();\n          const tableSize = lazySizing(table);\n          const col = isPreserveTableColumnResizing(editor) || isRightEdgeResize ? getNumColumns(table) - 1 : 0;\n          adjustWidth(table, width - startW, col, resizing, tableSize);\n        } else if (isPercentage$1(startRawW)) {\n          const percentW = parseFloat(startRawW.replace('%', ''));\n          const targetPercentW = width * percentW / startW;\n          set$1(table, 'width', targetPercentW + '%');\n        }\n        if (isPixel(startRawW)) {\n          syncPixels(table);\n        }\n      };\n      const destroy = () => {\n        tableResize.on(sz => {\n          sz.destroy();\n        });\n        resizeWire.on(w => {\n          remove(editor, w);\n        });\n      };\n      editor.on('init', () => {\n        const rawWire = get(editor, isResizable);\n        resizeWire.set(rawWire);\n        if (hasTableObjectResizing(editor) && hasTableResizeBars(editor)) {\n          const resizing = lazyResizingBehaviour();\n          const sz = TableResize.create(rawWire, resizing, lazySizing);\n          sz.on();\n          sz.events.startDrag.bind(_event => {\n            selectionRng.set(editor.selection.getRng());\n          });\n          sz.events.beforeResize.bind(event => {\n            const rawTable = event.table.dom;\n            fireObjectResizeStart(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);\n          });\n          sz.events.afterResize.bind(event => {\n            const table = event.table;\n            const rawTable = table.dom;\n            removeDataStyle(table);\n            selectionRng.on(rng => {\n              editor.selection.setRng(rng);\n              editor.focus();\n            });\n            fireObjectResized(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);\n            editor.undoManager.add();\n          });\n          tableResize.set(sz);\n        }\n      });\n      editor.on('ObjectResizeStart', e => {\n        const targetElm = e.target;\n        if (isTable(targetElm)) {\n          const table = SugarElement.fromDom(targetElm);\n          each$2(editor.dom.select('.mce-clonedresizable'), clone => {\n            editor.dom.addClass(clone, 'mce-' + getTableColumnResizingBehaviour(editor) + '-columns');\n          });\n          if (!isPixelSizing(table) && isTablePixelsForced(editor)) {\n            convertToPixelSize(table);\n          } else if (!isPercentSizing(table) && isTablePercentagesForced(editor)) {\n            convertToPercentSize(table);\n          }\n          if (isNoneSizing(table) && startsWith(e.origin, barResizerPrefix)) {\n            convertToPercentSize(table);\n          }\n          startW = e.width;\n          startRawW = isTableResponsiveForced(editor) ? '' : getRawWidth(editor, targetElm).getOr('');\n        }\n      });\n      editor.on('ObjectResized', e => {\n        const targetElm = e.target;\n        if (isTable(targetElm)) {\n          const table = SugarElement.fromDom(targetElm);\n          const origin = e.origin;\n          if (startsWith(origin, 'corner-')) {\n            afterCornerResize(table, origin, e.width);\n          }\n          removeDataStyle(table);\n          fireTableModified(editor, table.dom, styleModified);\n        }\n      });\n      editor.on('SwitchMode', () => {\n        tableResize.on(resize => {\n          if (editor.mode.isReadOnly()) {\n            resize.hideBars();\n          } else {\n            resize.showBars();\n          }\n        });\n      });\n      editor.on('remove', () => {\n        destroy();\n      });\n      const refresh = table => {\n        tableResize.on(resize => resize.refreshBars(SugarElement.fromDom(table)));\n      };\n      const hide = () => {\n        tableResize.on(resize => resize.hideBars());\n      };\n      const show = () => {\n        tableResize.on(resize => resize.showBars());\n      };\n      return {\n        refresh,\n        hide,\n        show\n      };\n    };\n\n    const setupTable = editor => {\n      register(editor);\n      const resizeHandler = TableResizeHandler(editor);\n      const cellSelectionHandler = TableCellSelectionHandler(editor, resizeHandler);\n      const actions = TableActions(editor, resizeHandler, cellSelectionHandler);\n      registerCommands(editor, actions);\n      registerQueryCommands(editor, actions);\n      registerEvents(editor, actions);\n      return {\n        getSelectedCells: cellSelectionHandler.getSelectedCells,\n        clearSelectedCells: cellSelectionHandler.clearSelectedCells\n      };\n    };\n\n    const DomModel = editor => {\n      const table = setupTable(editor);\n      return { table };\n    };\n    var Model = () => {\n      global$1.add('dom', DomModel);\n    };\n\n    Model();\n\n})();\n", "// Exports the \"dom\" model for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/models/dom')\n//   ES2015:\n//     import 'tinymce/models/dom'\nrequire('./model.js');", "export default require(\"./node_modules/tinymce/models/dom/index.js\");"],
  "mappings": "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",
  "names": []
}
